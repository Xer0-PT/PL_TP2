Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> command
Rule 2     program -> program command
Rule 3     command -> forward NUMBER
Rule 4     command -> fd NUMBER
Rule 5     command -> forward : VAR
Rule 6     command -> fd : VAR
Rule 7     command -> right NUMBER
Rule 8     command -> rt NUMBER
Rule 9     command -> right : VAR
Rule 10    command -> rt : VAR
Rule 11    command -> back NUMBER
Rule 12    command -> bk NUMBER
Rule 13    command -> back : VAR
Rule 14    command -> bk : VAR
Rule 15    command -> left NUMBER
Rule 16    command -> lt NUMBER
Rule 17    command -> left : VAR
Rule 18    command -> lt : VAR
Rule 19    command -> setpos [ NUMBER NUMBER ]
Rule 20    command -> setxy NUMBER NUMBER
Rule 21    command -> setpos [ : VAR NUMBER ]
Rule 22    command -> setpos [ NUMBER : VAR ]
Rule 23    command -> setpos [ : VAR : VAR ]
Rule 24    command -> setxy : VAR NUMBER
Rule 25    command -> setxy NUMBER : VAR
Rule 26    command -> setxy : VAR : VAR
Rule 27    command -> setx NUMBER
Rule 28    command -> setx : VAR
Rule 29    command -> sety NUMBER
Rule 30    command -> sety : VAR
Rule 31    command -> home
Rule 32    command -> pendown
Rule 33    command -> pd
Rule 34    command -> penup
Rule 35    command -> pu
Rule 36    command -> setpencolor [ NUMBER NUMBER NUMBER ]
Rule 37    command -> setpencolor [ NUMBER NUMBER : VAR ]
Rule 38    command -> setpencolor [ NUMBER : VAR NUMBER ]
Rule 39    command -> setpencolor [ NUMBER : VAR : VAR ]
Rule 40    command -> setpencolor [ : VAR NUMBER NUMBER ]
Rule 41    command -> setpencolor [ : VAR NUMBER : VAR ]
Rule 42    command -> setpencolor [ : VAR : VAR NUMBER ]
Rule 43    command -> setpencolor [ : VAR : VAR : VAR ]
Rule 44    command -> make " VAR NUMBER
Rule 45    command -> make " VAR : VAR OPERATOR NUMBER
Rule 46    command -> make " VAR NUMBER OPERATOR : VAR
Rule 47    command -> repeat NUMBER [ program ]
Rule 48    command -> repeat : VAR [ program ]
Rule 49    command -> while [ : VAR SIGN NUMBER ] [ program ]
Rule 50    command -> if NUMBER SIGN NUMBER [ program ]
Rule 51    command -> if : VAR SIGN NUMBER [ program ]
Rule 52    command -> if NUMBER SIGN : VAR [ program ]
Rule 53    command -> if : VAR SIGN : VAR [ program ]
Rule 54    command -> if [ NUMBER SIGN NUMBER ] [ program ]
Rule 55    command -> if [ : VAR SIGN NUMBER ] [ program ]
Rule 56    command -> if [ NUMBER SIGN : VAR ] [ program ]
Rule 57    command -> if [ : VAR SIGN : VAR ] [ program ]
Rule 58    command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ]
Rule 59    command -> ifelse : VAR SIGN NUMBER [ program ] [ program ]
Rule 60    command -> ifelse NUMBER SIGN : VAR [ program ] [ program ]
Rule 61    command -> ifelse : VAR SIGN : VAR [ program ] [ program ]
Rule 62    command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
Rule 63    command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
Rule 64    command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
Rule 65    command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
Rule 66    varlist -> <empty>
Rule 67    varlist -> : VAR
Rule 68    varlist -> varlist : VAR
Rule 69    command -> TO STR varlist program END
Rule 70    valuelist -> <empty>
Rule 71    valuelist -> NUMBER
Rule 72    valuelist -> valuelist NUMBER
Rule 73    command -> STR valuelist

Terminals, with rules where they appear

"                    : 44 45 46
:                    : 5 6 9 10 13 14 17 18 21 22 23 23 24 25 26 26 28 30 37 38 39 39 40 41 41 42 42 43 43 43 45 46 48 49 51 52 53 53 55 56 57 57 59 60 61 61 63 64 65 65 67 68
END                  : 69
NUMBER               : 3 4 7 8 11 12 15 16 19 19 20 20 21 22 24 25 27 29 36 36 36 37 37 38 38 39 40 40 41 42 44 45 46 47 49 50 50 51 52 54 54 55 56 58 58 59 60 62 62 63 64 71 72
OPERATOR             : 45 46
SIGN                 : 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65
STR                  : 69 73
TO                   : 69
VAR                  : 5 6 9 10 13 14 17 18 21 22 23 23 24 25 26 26 28 30 37 38 39 39 40 41 41 42 42 43 43 43 44 45 45 46 46 48 49 51 52 53 53 55 56 57 57 59 60 61 61 63 64 65 65 67 68
[                    : 19 21 22 23 36 37 38 39 40 41 42 43 47 48 49 49 50 51 52 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 62 63 63 63 64 64 64 65 65 65
]                    : 19 21 22 23 36 37 38 39 40 41 42 43 47 48 49 49 50 51 52 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 62 63 63 63 64 64 64 65 65 65
back                 : 11 13
bk                   : 12 14
error                : 
fd                   : 4 6
forward              : 3 5
home                 : 31
if                   : 50 51 52 53 54 55 56 57
ifelse               : 58 59 60 61 62 63 64 65
left                 : 15 17
lt                   : 16 18
make                 : 44 45 46
pd                   : 33
pendown              : 32
penup                : 34
pu                   : 35
repeat               : 47 48
right                : 7 9
rt                   : 8 10
setpencolor          : 36 37 38 39 40 41 42 43
setpos               : 19 21 22 23
setx                 : 27 28
setxy                : 20 24 25 26
sety                 : 29 30
while                : 49

Nonterminals, with rules where they appear

command              : 1 2
program              : 2 47 48 49 50 51 52 53 54 55 56 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 69 0
valuelist            : 72 73
varlist              : 68 69

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 1
    command                        shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 2

    (1) program -> command .

    forward         reduce using rule 1 (program -> command .)
    fd              reduce using rule 1 (program -> command .)
    right           reduce using rule 1 (program -> command .)
    rt              reduce using rule 1 (program -> command .)
    back            reduce using rule 1 (program -> command .)
    bk              reduce using rule 1 (program -> command .)
    left            reduce using rule 1 (program -> command .)
    lt              reduce using rule 1 (program -> command .)
    setpos          reduce using rule 1 (program -> command .)
    setxy           reduce using rule 1 (program -> command .)
    setx            reduce using rule 1 (program -> command .)
    sety            reduce using rule 1 (program -> command .)
    home            reduce using rule 1 (program -> command .)
    pendown         reduce using rule 1 (program -> command .)
    pd              reduce using rule 1 (program -> command .)
    penup           reduce using rule 1 (program -> command .)
    pu              reduce using rule 1 (program -> command .)
    setpencolor     reduce using rule 1 (program -> command .)
    make            reduce using rule 1 (program -> command .)
    repeat          reduce using rule 1 (program -> command .)
    while           reduce using rule 1 (program -> command .)
    if              reduce using rule 1 (program -> command .)
    ifelse          reduce using rule 1 (program -> command .)
    TO              reduce using rule 1 (program -> command .)
    STR             reduce using rule 1 (program -> command .)
    $end            reduce using rule 1 (program -> command .)
    ]               reduce using rule 1 (program -> command .)
    END             reduce using rule 1 (program -> command .)


state 3

    (3) command -> forward . NUMBER
    (5) command -> forward . : VAR

    NUMBER          shift and go to state 29
    :               shift and go to state 30


state 4

    (4) command -> fd . NUMBER
    (6) command -> fd . : VAR

    NUMBER          shift and go to state 31
    :               shift and go to state 32


state 5

    (7) command -> right . NUMBER
    (9) command -> right . : VAR

    NUMBER          shift and go to state 33
    :               shift and go to state 34


state 6

    (8) command -> rt . NUMBER
    (10) command -> rt . : VAR

    NUMBER          shift and go to state 35
    :               shift and go to state 36


state 7

    (11) command -> back . NUMBER
    (13) command -> back . : VAR

    NUMBER          shift and go to state 37
    :               shift and go to state 38


state 8

    (12) command -> bk . NUMBER
    (14) command -> bk . : VAR

    NUMBER          shift and go to state 39
    :               shift and go to state 40


state 9

    (15) command -> left . NUMBER
    (17) command -> left . : VAR

    NUMBER          shift and go to state 41
    :               shift and go to state 42


state 10

    (16) command -> lt . NUMBER
    (18) command -> lt . : VAR

    NUMBER          shift and go to state 43
    :               shift and go to state 44


state 11

    (19) command -> setpos . [ NUMBER NUMBER ]
    (21) command -> setpos . [ : VAR NUMBER ]
    (22) command -> setpos . [ NUMBER : VAR ]
    (23) command -> setpos . [ : VAR : VAR ]

    [               shift and go to state 45


state 12

    (20) command -> setxy . NUMBER NUMBER
    (24) command -> setxy . : VAR NUMBER
    (25) command -> setxy . NUMBER : VAR
    (26) command -> setxy . : VAR : VAR

    NUMBER          shift and go to state 46
    :               shift and go to state 47


state 13

    (27) command -> setx . NUMBER
    (28) command -> setx . : VAR

    NUMBER          shift and go to state 48
    :               shift and go to state 49


state 14

    (29) command -> sety . NUMBER
    (30) command -> sety . : VAR

    NUMBER          shift and go to state 50
    :               shift and go to state 51


state 15

    (31) command -> home .

    forward         reduce using rule 31 (command -> home .)
    fd              reduce using rule 31 (command -> home .)
    right           reduce using rule 31 (command -> home .)
    rt              reduce using rule 31 (command -> home .)
    back            reduce using rule 31 (command -> home .)
    bk              reduce using rule 31 (command -> home .)
    left            reduce using rule 31 (command -> home .)
    lt              reduce using rule 31 (command -> home .)
    setpos          reduce using rule 31 (command -> home .)
    setxy           reduce using rule 31 (command -> home .)
    setx            reduce using rule 31 (command -> home .)
    sety            reduce using rule 31 (command -> home .)
    home            reduce using rule 31 (command -> home .)
    pendown         reduce using rule 31 (command -> home .)
    pd              reduce using rule 31 (command -> home .)
    penup           reduce using rule 31 (command -> home .)
    pu              reduce using rule 31 (command -> home .)
    setpencolor     reduce using rule 31 (command -> home .)
    make            reduce using rule 31 (command -> home .)
    repeat          reduce using rule 31 (command -> home .)
    while           reduce using rule 31 (command -> home .)
    if              reduce using rule 31 (command -> home .)
    ifelse          reduce using rule 31 (command -> home .)
    TO              reduce using rule 31 (command -> home .)
    STR             reduce using rule 31 (command -> home .)
    $end            reduce using rule 31 (command -> home .)
    ]               reduce using rule 31 (command -> home .)
    END             reduce using rule 31 (command -> home .)


state 16

    (32) command -> pendown .

    forward         reduce using rule 32 (command -> pendown .)
    fd              reduce using rule 32 (command -> pendown .)
    right           reduce using rule 32 (command -> pendown .)
    rt              reduce using rule 32 (command -> pendown .)
    back            reduce using rule 32 (command -> pendown .)
    bk              reduce using rule 32 (command -> pendown .)
    left            reduce using rule 32 (command -> pendown .)
    lt              reduce using rule 32 (command -> pendown .)
    setpos          reduce using rule 32 (command -> pendown .)
    setxy           reduce using rule 32 (command -> pendown .)
    setx            reduce using rule 32 (command -> pendown .)
    sety            reduce using rule 32 (command -> pendown .)
    home            reduce using rule 32 (command -> pendown .)
    pendown         reduce using rule 32 (command -> pendown .)
    pd              reduce using rule 32 (command -> pendown .)
    penup           reduce using rule 32 (command -> pendown .)
    pu              reduce using rule 32 (command -> pendown .)
    setpencolor     reduce using rule 32 (command -> pendown .)
    make            reduce using rule 32 (command -> pendown .)
    repeat          reduce using rule 32 (command -> pendown .)
    while           reduce using rule 32 (command -> pendown .)
    if              reduce using rule 32 (command -> pendown .)
    ifelse          reduce using rule 32 (command -> pendown .)
    TO              reduce using rule 32 (command -> pendown .)
    STR             reduce using rule 32 (command -> pendown .)
    $end            reduce using rule 32 (command -> pendown .)
    ]               reduce using rule 32 (command -> pendown .)
    END             reduce using rule 32 (command -> pendown .)


state 17

    (33) command -> pd .

    forward         reduce using rule 33 (command -> pd .)
    fd              reduce using rule 33 (command -> pd .)
    right           reduce using rule 33 (command -> pd .)
    rt              reduce using rule 33 (command -> pd .)
    back            reduce using rule 33 (command -> pd .)
    bk              reduce using rule 33 (command -> pd .)
    left            reduce using rule 33 (command -> pd .)
    lt              reduce using rule 33 (command -> pd .)
    setpos          reduce using rule 33 (command -> pd .)
    setxy           reduce using rule 33 (command -> pd .)
    setx            reduce using rule 33 (command -> pd .)
    sety            reduce using rule 33 (command -> pd .)
    home            reduce using rule 33 (command -> pd .)
    pendown         reduce using rule 33 (command -> pd .)
    pd              reduce using rule 33 (command -> pd .)
    penup           reduce using rule 33 (command -> pd .)
    pu              reduce using rule 33 (command -> pd .)
    setpencolor     reduce using rule 33 (command -> pd .)
    make            reduce using rule 33 (command -> pd .)
    repeat          reduce using rule 33 (command -> pd .)
    while           reduce using rule 33 (command -> pd .)
    if              reduce using rule 33 (command -> pd .)
    ifelse          reduce using rule 33 (command -> pd .)
    TO              reduce using rule 33 (command -> pd .)
    STR             reduce using rule 33 (command -> pd .)
    $end            reduce using rule 33 (command -> pd .)
    ]               reduce using rule 33 (command -> pd .)
    END             reduce using rule 33 (command -> pd .)


state 18

    (34) command -> penup .

    forward         reduce using rule 34 (command -> penup .)
    fd              reduce using rule 34 (command -> penup .)
    right           reduce using rule 34 (command -> penup .)
    rt              reduce using rule 34 (command -> penup .)
    back            reduce using rule 34 (command -> penup .)
    bk              reduce using rule 34 (command -> penup .)
    left            reduce using rule 34 (command -> penup .)
    lt              reduce using rule 34 (command -> penup .)
    setpos          reduce using rule 34 (command -> penup .)
    setxy           reduce using rule 34 (command -> penup .)
    setx            reduce using rule 34 (command -> penup .)
    sety            reduce using rule 34 (command -> penup .)
    home            reduce using rule 34 (command -> penup .)
    pendown         reduce using rule 34 (command -> penup .)
    pd              reduce using rule 34 (command -> penup .)
    penup           reduce using rule 34 (command -> penup .)
    pu              reduce using rule 34 (command -> penup .)
    setpencolor     reduce using rule 34 (command -> penup .)
    make            reduce using rule 34 (command -> penup .)
    repeat          reduce using rule 34 (command -> penup .)
    while           reduce using rule 34 (command -> penup .)
    if              reduce using rule 34 (command -> penup .)
    ifelse          reduce using rule 34 (command -> penup .)
    TO              reduce using rule 34 (command -> penup .)
    STR             reduce using rule 34 (command -> penup .)
    $end            reduce using rule 34 (command -> penup .)
    ]               reduce using rule 34 (command -> penup .)
    END             reduce using rule 34 (command -> penup .)


state 19

    (35) command -> pu .

    forward         reduce using rule 35 (command -> pu .)
    fd              reduce using rule 35 (command -> pu .)
    right           reduce using rule 35 (command -> pu .)
    rt              reduce using rule 35 (command -> pu .)
    back            reduce using rule 35 (command -> pu .)
    bk              reduce using rule 35 (command -> pu .)
    left            reduce using rule 35 (command -> pu .)
    lt              reduce using rule 35 (command -> pu .)
    setpos          reduce using rule 35 (command -> pu .)
    setxy           reduce using rule 35 (command -> pu .)
    setx            reduce using rule 35 (command -> pu .)
    sety            reduce using rule 35 (command -> pu .)
    home            reduce using rule 35 (command -> pu .)
    pendown         reduce using rule 35 (command -> pu .)
    pd              reduce using rule 35 (command -> pu .)
    penup           reduce using rule 35 (command -> pu .)
    pu              reduce using rule 35 (command -> pu .)
    setpencolor     reduce using rule 35 (command -> pu .)
    make            reduce using rule 35 (command -> pu .)
    repeat          reduce using rule 35 (command -> pu .)
    while           reduce using rule 35 (command -> pu .)
    if              reduce using rule 35 (command -> pu .)
    ifelse          reduce using rule 35 (command -> pu .)
    TO              reduce using rule 35 (command -> pu .)
    STR             reduce using rule 35 (command -> pu .)
    $end            reduce using rule 35 (command -> pu .)
    ]               reduce using rule 35 (command -> pu .)
    END             reduce using rule 35 (command -> pu .)


state 20

    (36) command -> setpencolor . [ NUMBER NUMBER NUMBER ]
    (37) command -> setpencolor . [ NUMBER NUMBER : VAR ]
    (38) command -> setpencolor . [ NUMBER : VAR NUMBER ]
    (39) command -> setpencolor . [ NUMBER : VAR : VAR ]
    (40) command -> setpencolor . [ : VAR NUMBER NUMBER ]
    (41) command -> setpencolor . [ : VAR NUMBER : VAR ]
    (42) command -> setpencolor . [ : VAR : VAR NUMBER ]
    (43) command -> setpencolor . [ : VAR : VAR : VAR ]

    [               shift and go to state 52


state 21

    (44) command -> make . " VAR NUMBER
    (45) command -> make . " VAR : VAR OPERATOR NUMBER
    (46) command -> make . " VAR NUMBER OPERATOR : VAR

    "               shift and go to state 53


state 22

    (47) command -> repeat . NUMBER [ program ]
    (48) command -> repeat . : VAR [ program ]

    NUMBER          shift and go to state 54
    :               shift and go to state 55


state 23

    (49) command -> while . [ : VAR SIGN NUMBER ] [ program ]

    [               shift and go to state 56


state 24

    (50) command -> if . NUMBER SIGN NUMBER [ program ]
    (51) command -> if . : VAR SIGN NUMBER [ program ]
    (52) command -> if . NUMBER SIGN : VAR [ program ]
    (53) command -> if . : VAR SIGN : VAR [ program ]
    (54) command -> if . [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> if . [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> if . [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> if . [ : VAR SIGN : VAR ] [ program ]

    NUMBER          shift and go to state 57
    :               shift and go to state 59
    [               shift and go to state 58


state 25

    (58) command -> ifelse . NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> ifelse . : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> ifelse . NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> ifelse . : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> ifelse . [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> ifelse . [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> ifelse . [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> ifelse . [ : VAR SIGN : VAR ] [ program ] [ program ]

    NUMBER          shift and go to state 60
    :               shift and go to state 62
    [               shift and go to state 61


state 26

    (69) command -> TO . STR varlist program END

    STR             shift and go to state 63


state 27

    (73) command -> STR . valuelist
    (70) valuelist -> .
    (71) valuelist -> . NUMBER
    (72) valuelist -> . valuelist NUMBER

  ! shift/reduce conflict for NUMBER resolved as shift
    forward         reduce using rule 70 (valuelist -> .)
    fd              reduce using rule 70 (valuelist -> .)
    right           reduce using rule 70 (valuelist -> .)
    rt              reduce using rule 70 (valuelist -> .)
    back            reduce using rule 70 (valuelist -> .)
    bk              reduce using rule 70 (valuelist -> .)
    left            reduce using rule 70 (valuelist -> .)
    lt              reduce using rule 70 (valuelist -> .)
    setpos          reduce using rule 70 (valuelist -> .)
    setxy           reduce using rule 70 (valuelist -> .)
    setx            reduce using rule 70 (valuelist -> .)
    sety            reduce using rule 70 (valuelist -> .)
    home            reduce using rule 70 (valuelist -> .)
    pendown         reduce using rule 70 (valuelist -> .)
    pd              reduce using rule 70 (valuelist -> .)
    penup           reduce using rule 70 (valuelist -> .)
    pu              reduce using rule 70 (valuelist -> .)
    setpencolor     reduce using rule 70 (valuelist -> .)
    make            reduce using rule 70 (valuelist -> .)
    repeat          reduce using rule 70 (valuelist -> .)
    while           reduce using rule 70 (valuelist -> .)
    if              reduce using rule 70 (valuelist -> .)
    ifelse          reduce using rule 70 (valuelist -> .)
    TO              reduce using rule 70 (valuelist -> .)
    STR             reduce using rule 70 (valuelist -> .)
    $end            reduce using rule 70 (valuelist -> .)
    ]               reduce using rule 70 (valuelist -> .)
    END             reduce using rule 70 (valuelist -> .)
    NUMBER          shift and go to state 65

  ! NUMBER          [ reduce using rule 70 (valuelist -> .) ]

    valuelist                      shift and go to state 64

state 28

    (2) program -> program command .

    forward         reduce using rule 2 (program -> program command .)
    fd              reduce using rule 2 (program -> program command .)
    right           reduce using rule 2 (program -> program command .)
    rt              reduce using rule 2 (program -> program command .)
    back            reduce using rule 2 (program -> program command .)
    bk              reduce using rule 2 (program -> program command .)
    left            reduce using rule 2 (program -> program command .)
    lt              reduce using rule 2 (program -> program command .)
    setpos          reduce using rule 2 (program -> program command .)
    setxy           reduce using rule 2 (program -> program command .)
    setx            reduce using rule 2 (program -> program command .)
    sety            reduce using rule 2 (program -> program command .)
    home            reduce using rule 2 (program -> program command .)
    pendown         reduce using rule 2 (program -> program command .)
    pd              reduce using rule 2 (program -> program command .)
    penup           reduce using rule 2 (program -> program command .)
    pu              reduce using rule 2 (program -> program command .)
    setpencolor     reduce using rule 2 (program -> program command .)
    make            reduce using rule 2 (program -> program command .)
    repeat          reduce using rule 2 (program -> program command .)
    while           reduce using rule 2 (program -> program command .)
    if              reduce using rule 2 (program -> program command .)
    ifelse          reduce using rule 2 (program -> program command .)
    TO              reduce using rule 2 (program -> program command .)
    STR             reduce using rule 2 (program -> program command .)
    $end            reduce using rule 2 (program -> program command .)
    ]               reduce using rule 2 (program -> program command .)
    END             reduce using rule 2 (program -> program command .)


state 29

    (3) command -> forward NUMBER .

    forward         reduce using rule 3 (command -> forward NUMBER .)
    fd              reduce using rule 3 (command -> forward NUMBER .)
    right           reduce using rule 3 (command -> forward NUMBER .)
    rt              reduce using rule 3 (command -> forward NUMBER .)
    back            reduce using rule 3 (command -> forward NUMBER .)
    bk              reduce using rule 3 (command -> forward NUMBER .)
    left            reduce using rule 3 (command -> forward NUMBER .)
    lt              reduce using rule 3 (command -> forward NUMBER .)
    setpos          reduce using rule 3 (command -> forward NUMBER .)
    setxy           reduce using rule 3 (command -> forward NUMBER .)
    setx            reduce using rule 3 (command -> forward NUMBER .)
    sety            reduce using rule 3 (command -> forward NUMBER .)
    home            reduce using rule 3 (command -> forward NUMBER .)
    pendown         reduce using rule 3 (command -> forward NUMBER .)
    pd              reduce using rule 3 (command -> forward NUMBER .)
    penup           reduce using rule 3 (command -> forward NUMBER .)
    pu              reduce using rule 3 (command -> forward NUMBER .)
    setpencolor     reduce using rule 3 (command -> forward NUMBER .)
    make            reduce using rule 3 (command -> forward NUMBER .)
    repeat          reduce using rule 3 (command -> forward NUMBER .)
    while           reduce using rule 3 (command -> forward NUMBER .)
    if              reduce using rule 3 (command -> forward NUMBER .)
    ifelse          reduce using rule 3 (command -> forward NUMBER .)
    TO              reduce using rule 3 (command -> forward NUMBER .)
    STR             reduce using rule 3 (command -> forward NUMBER .)
    $end            reduce using rule 3 (command -> forward NUMBER .)
    ]               reduce using rule 3 (command -> forward NUMBER .)
    END             reduce using rule 3 (command -> forward NUMBER .)


state 30

    (5) command -> forward : . VAR

    VAR             shift and go to state 66


state 31

    (4) command -> fd NUMBER .

    forward         reduce using rule 4 (command -> fd NUMBER .)
    fd              reduce using rule 4 (command -> fd NUMBER .)
    right           reduce using rule 4 (command -> fd NUMBER .)
    rt              reduce using rule 4 (command -> fd NUMBER .)
    back            reduce using rule 4 (command -> fd NUMBER .)
    bk              reduce using rule 4 (command -> fd NUMBER .)
    left            reduce using rule 4 (command -> fd NUMBER .)
    lt              reduce using rule 4 (command -> fd NUMBER .)
    setpos          reduce using rule 4 (command -> fd NUMBER .)
    setxy           reduce using rule 4 (command -> fd NUMBER .)
    setx            reduce using rule 4 (command -> fd NUMBER .)
    sety            reduce using rule 4 (command -> fd NUMBER .)
    home            reduce using rule 4 (command -> fd NUMBER .)
    pendown         reduce using rule 4 (command -> fd NUMBER .)
    pd              reduce using rule 4 (command -> fd NUMBER .)
    penup           reduce using rule 4 (command -> fd NUMBER .)
    pu              reduce using rule 4 (command -> fd NUMBER .)
    setpencolor     reduce using rule 4 (command -> fd NUMBER .)
    make            reduce using rule 4 (command -> fd NUMBER .)
    repeat          reduce using rule 4 (command -> fd NUMBER .)
    while           reduce using rule 4 (command -> fd NUMBER .)
    if              reduce using rule 4 (command -> fd NUMBER .)
    ifelse          reduce using rule 4 (command -> fd NUMBER .)
    TO              reduce using rule 4 (command -> fd NUMBER .)
    STR             reduce using rule 4 (command -> fd NUMBER .)
    $end            reduce using rule 4 (command -> fd NUMBER .)
    ]               reduce using rule 4 (command -> fd NUMBER .)
    END             reduce using rule 4 (command -> fd NUMBER .)


state 32

    (6) command -> fd : . VAR

    VAR             shift and go to state 67


state 33

    (7) command -> right NUMBER .

    forward         reduce using rule 7 (command -> right NUMBER .)
    fd              reduce using rule 7 (command -> right NUMBER .)
    right           reduce using rule 7 (command -> right NUMBER .)
    rt              reduce using rule 7 (command -> right NUMBER .)
    back            reduce using rule 7 (command -> right NUMBER .)
    bk              reduce using rule 7 (command -> right NUMBER .)
    left            reduce using rule 7 (command -> right NUMBER .)
    lt              reduce using rule 7 (command -> right NUMBER .)
    setpos          reduce using rule 7 (command -> right NUMBER .)
    setxy           reduce using rule 7 (command -> right NUMBER .)
    setx            reduce using rule 7 (command -> right NUMBER .)
    sety            reduce using rule 7 (command -> right NUMBER .)
    home            reduce using rule 7 (command -> right NUMBER .)
    pendown         reduce using rule 7 (command -> right NUMBER .)
    pd              reduce using rule 7 (command -> right NUMBER .)
    penup           reduce using rule 7 (command -> right NUMBER .)
    pu              reduce using rule 7 (command -> right NUMBER .)
    setpencolor     reduce using rule 7 (command -> right NUMBER .)
    make            reduce using rule 7 (command -> right NUMBER .)
    repeat          reduce using rule 7 (command -> right NUMBER .)
    while           reduce using rule 7 (command -> right NUMBER .)
    if              reduce using rule 7 (command -> right NUMBER .)
    ifelse          reduce using rule 7 (command -> right NUMBER .)
    TO              reduce using rule 7 (command -> right NUMBER .)
    STR             reduce using rule 7 (command -> right NUMBER .)
    $end            reduce using rule 7 (command -> right NUMBER .)
    ]               reduce using rule 7 (command -> right NUMBER .)
    END             reduce using rule 7 (command -> right NUMBER .)


state 34

    (9) command -> right : . VAR

    VAR             shift and go to state 68


state 35

    (8) command -> rt NUMBER .

    forward         reduce using rule 8 (command -> rt NUMBER .)
    fd              reduce using rule 8 (command -> rt NUMBER .)
    right           reduce using rule 8 (command -> rt NUMBER .)
    rt              reduce using rule 8 (command -> rt NUMBER .)
    back            reduce using rule 8 (command -> rt NUMBER .)
    bk              reduce using rule 8 (command -> rt NUMBER .)
    left            reduce using rule 8 (command -> rt NUMBER .)
    lt              reduce using rule 8 (command -> rt NUMBER .)
    setpos          reduce using rule 8 (command -> rt NUMBER .)
    setxy           reduce using rule 8 (command -> rt NUMBER .)
    setx            reduce using rule 8 (command -> rt NUMBER .)
    sety            reduce using rule 8 (command -> rt NUMBER .)
    home            reduce using rule 8 (command -> rt NUMBER .)
    pendown         reduce using rule 8 (command -> rt NUMBER .)
    pd              reduce using rule 8 (command -> rt NUMBER .)
    penup           reduce using rule 8 (command -> rt NUMBER .)
    pu              reduce using rule 8 (command -> rt NUMBER .)
    setpencolor     reduce using rule 8 (command -> rt NUMBER .)
    make            reduce using rule 8 (command -> rt NUMBER .)
    repeat          reduce using rule 8 (command -> rt NUMBER .)
    while           reduce using rule 8 (command -> rt NUMBER .)
    if              reduce using rule 8 (command -> rt NUMBER .)
    ifelse          reduce using rule 8 (command -> rt NUMBER .)
    TO              reduce using rule 8 (command -> rt NUMBER .)
    STR             reduce using rule 8 (command -> rt NUMBER .)
    $end            reduce using rule 8 (command -> rt NUMBER .)
    ]               reduce using rule 8 (command -> rt NUMBER .)
    END             reduce using rule 8 (command -> rt NUMBER .)


state 36

    (10) command -> rt : . VAR

    VAR             shift and go to state 69


state 37

    (11) command -> back NUMBER .

    forward         reduce using rule 11 (command -> back NUMBER .)
    fd              reduce using rule 11 (command -> back NUMBER .)
    right           reduce using rule 11 (command -> back NUMBER .)
    rt              reduce using rule 11 (command -> back NUMBER .)
    back            reduce using rule 11 (command -> back NUMBER .)
    bk              reduce using rule 11 (command -> back NUMBER .)
    left            reduce using rule 11 (command -> back NUMBER .)
    lt              reduce using rule 11 (command -> back NUMBER .)
    setpos          reduce using rule 11 (command -> back NUMBER .)
    setxy           reduce using rule 11 (command -> back NUMBER .)
    setx            reduce using rule 11 (command -> back NUMBER .)
    sety            reduce using rule 11 (command -> back NUMBER .)
    home            reduce using rule 11 (command -> back NUMBER .)
    pendown         reduce using rule 11 (command -> back NUMBER .)
    pd              reduce using rule 11 (command -> back NUMBER .)
    penup           reduce using rule 11 (command -> back NUMBER .)
    pu              reduce using rule 11 (command -> back NUMBER .)
    setpencolor     reduce using rule 11 (command -> back NUMBER .)
    make            reduce using rule 11 (command -> back NUMBER .)
    repeat          reduce using rule 11 (command -> back NUMBER .)
    while           reduce using rule 11 (command -> back NUMBER .)
    if              reduce using rule 11 (command -> back NUMBER .)
    ifelse          reduce using rule 11 (command -> back NUMBER .)
    TO              reduce using rule 11 (command -> back NUMBER .)
    STR             reduce using rule 11 (command -> back NUMBER .)
    $end            reduce using rule 11 (command -> back NUMBER .)
    ]               reduce using rule 11 (command -> back NUMBER .)
    END             reduce using rule 11 (command -> back NUMBER .)


state 38

    (13) command -> back : . VAR

    VAR             shift and go to state 70


state 39

    (12) command -> bk NUMBER .

    forward         reduce using rule 12 (command -> bk NUMBER .)
    fd              reduce using rule 12 (command -> bk NUMBER .)
    right           reduce using rule 12 (command -> bk NUMBER .)
    rt              reduce using rule 12 (command -> bk NUMBER .)
    back            reduce using rule 12 (command -> bk NUMBER .)
    bk              reduce using rule 12 (command -> bk NUMBER .)
    left            reduce using rule 12 (command -> bk NUMBER .)
    lt              reduce using rule 12 (command -> bk NUMBER .)
    setpos          reduce using rule 12 (command -> bk NUMBER .)
    setxy           reduce using rule 12 (command -> bk NUMBER .)
    setx            reduce using rule 12 (command -> bk NUMBER .)
    sety            reduce using rule 12 (command -> bk NUMBER .)
    home            reduce using rule 12 (command -> bk NUMBER .)
    pendown         reduce using rule 12 (command -> bk NUMBER .)
    pd              reduce using rule 12 (command -> bk NUMBER .)
    penup           reduce using rule 12 (command -> bk NUMBER .)
    pu              reduce using rule 12 (command -> bk NUMBER .)
    setpencolor     reduce using rule 12 (command -> bk NUMBER .)
    make            reduce using rule 12 (command -> bk NUMBER .)
    repeat          reduce using rule 12 (command -> bk NUMBER .)
    while           reduce using rule 12 (command -> bk NUMBER .)
    if              reduce using rule 12 (command -> bk NUMBER .)
    ifelse          reduce using rule 12 (command -> bk NUMBER .)
    TO              reduce using rule 12 (command -> bk NUMBER .)
    STR             reduce using rule 12 (command -> bk NUMBER .)
    $end            reduce using rule 12 (command -> bk NUMBER .)
    ]               reduce using rule 12 (command -> bk NUMBER .)
    END             reduce using rule 12 (command -> bk NUMBER .)


state 40

    (14) command -> bk : . VAR

    VAR             shift and go to state 71


state 41

    (15) command -> left NUMBER .

    forward         reduce using rule 15 (command -> left NUMBER .)
    fd              reduce using rule 15 (command -> left NUMBER .)
    right           reduce using rule 15 (command -> left NUMBER .)
    rt              reduce using rule 15 (command -> left NUMBER .)
    back            reduce using rule 15 (command -> left NUMBER .)
    bk              reduce using rule 15 (command -> left NUMBER .)
    left            reduce using rule 15 (command -> left NUMBER .)
    lt              reduce using rule 15 (command -> left NUMBER .)
    setpos          reduce using rule 15 (command -> left NUMBER .)
    setxy           reduce using rule 15 (command -> left NUMBER .)
    setx            reduce using rule 15 (command -> left NUMBER .)
    sety            reduce using rule 15 (command -> left NUMBER .)
    home            reduce using rule 15 (command -> left NUMBER .)
    pendown         reduce using rule 15 (command -> left NUMBER .)
    pd              reduce using rule 15 (command -> left NUMBER .)
    penup           reduce using rule 15 (command -> left NUMBER .)
    pu              reduce using rule 15 (command -> left NUMBER .)
    setpencolor     reduce using rule 15 (command -> left NUMBER .)
    make            reduce using rule 15 (command -> left NUMBER .)
    repeat          reduce using rule 15 (command -> left NUMBER .)
    while           reduce using rule 15 (command -> left NUMBER .)
    if              reduce using rule 15 (command -> left NUMBER .)
    ifelse          reduce using rule 15 (command -> left NUMBER .)
    TO              reduce using rule 15 (command -> left NUMBER .)
    STR             reduce using rule 15 (command -> left NUMBER .)
    $end            reduce using rule 15 (command -> left NUMBER .)
    ]               reduce using rule 15 (command -> left NUMBER .)
    END             reduce using rule 15 (command -> left NUMBER .)


state 42

    (17) command -> left : . VAR

    VAR             shift and go to state 72


state 43

    (16) command -> lt NUMBER .

    forward         reduce using rule 16 (command -> lt NUMBER .)
    fd              reduce using rule 16 (command -> lt NUMBER .)
    right           reduce using rule 16 (command -> lt NUMBER .)
    rt              reduce using rule 16 (command -> lt NUMBER .)
    back            reduce using rule 16 (command -> lt NUMBER .)
    bk              reduce using rule 16 (command -> lt NUMBER .)
    left            reduce using rule 16 (command -> lt NUMBER .)
    lt              reduce using rule 16 (command -> lt NUMBER .)
    setpos          reduce using rule 16 (command -> lt NUMBER .)
    setxy           reduce using rule 16 (command -> lt NUMBER .)
    setx            reduce using rule 16 (command -> lt NUMBER .)
    sety            reduce using rule 16 (command -> lt NUMBER .)
    home            reduce using rule 16 (command -> lt NUMBER .)
    pendown         reduce using rule 16 (command -> lt NUMBER .)
    pd              reduce using rule 16 (command -> lt NUMBER .)
    penup           reduce using rule 16 (command -> lt NUMBER .)
    pu              reduce using rule 16 (command -> lt NUMBER .)
    setpencolor     reduce using rule 16 (command -> lt NUMBER .)
    make            reduce using rule 16 (command -> lt NUMBER .)
    repeat          reduce using rule 16 (command -> lt NUMBER .)
    while           reduce using rule 16 (command -> lt NUMBER .)
    if              reduce using rule 16 (command -> lt NUMBER .)
    ifelse          reduce using rule 16 (command -> lt NUMBER .)
    TO              reduce using rule 16 (command -> lt NUMBER .)
    STR             reduce using rule 16 (command -> lt NUMBER .)
    $end            reduce using rule 16 (command -> lt NUMBER .)
    ]               reduce using rule 16 (command -> lt NUMBER .)
    END             reduce using rule 16 (command -> lt NUMBER .)


state 44

    (18) command -> lt : . VAR

    VAR             shift and go to state 73


state 45

    (19) command -> setpos [ . NUMBER NUMBER ]
    (21) command -> setpos [ . : VAR NUMBER ]
    (22) command -> setpos [ . NUMBER : VAR ]
    (23) command -> setpos [ . : VAR : VAR ]

    NUMBER          shift and go to state 74
    :               shift and go to state 75


state 46

    (20) command -> setxy NUMBER . NUMBER
    (25) command -> setxy NUMBER . : VAR

    NUMBER          shift and go to state 76
    :               shift and go to state 77


state 47

    (24) command -> setxy : . VAR NUMBER
    (26) command -> setxy : . VAR : VAR

    VAR             shift and go to state 78


state 48

    (27) command -> setx NUMBER .

    forward         reduce using rule 27 (command -> setx NUMBER .)
    fd              reduce using rule 27 (command -> setx NUMBER .)
    right           reduce using rule 27 (command -> setx NUMBER .)
    rt              reduce using rule 27 (command -> setx NUMBER .)
    back            reduce using rule 27 (command -> setx NUMBER .)
    bk              reduce using rule 27 (command -> setx NUMBER .)
    left            reduce using rule 27 (command -> setx NUMBER .)
    lt              reduce using rule 27 (command -> setx NUMBER .)
    setpos          reduce using rule 27 (command -> setx NUMBER .)
    setxy           reduce using rule 27 (command -> setx NUMBER .)
    setx            reduce using rule 27 (command -> setx NUMBER .)
    sety            reduce using rule 27 (command -> setx NUMBER .)
    home            reduce using rule 27 (command -> setx NUMBER .)
    pendown         reduce using rule 27 (command -> setx NUMBER .)
    pd              reduce using rule 27 (command -> setx NUMBER .)
    penup           reduce using rule 27 (command -> setx NUMBER .)
    pu              reduce using rule 27 (command -> setx NUMBER .)
    setpencolor     reduce using rule 27 (command -> setx NUMBER .)
    make            reduce using rule 27 (command -> setx NUMBER .)
    repeat          reduce using rule 27 (command -> setx NUMBER .)
    while           reduce using rule 27 (command -> setx NUMBER .)
    if              reduce using rule 27 (command -> setx NUMBER .)
    ifelse          reduce using rule 27 (command -> setx NUMBER .)
    TO              reduce using rule 27 (command -> setx NUMBER .)
    STR             reduce using rule 27 (command -> setx NUMBER .)
    $end            reduce using rule 27 (command -> setx NUMBER .)
    ]               reduce using rule 27 (command -> setx NUMBER .)
    END             reduce using rule 27 (command -> setx NUMBER .)


state 49

    (28) command -> setx : . VAR

    VAR             shift and go to state 79


state 50

    (29) command -> sety NUMBER .

    forward         reduce using rule 29 (command -> sety NUMBER .)
    fd              reduce using rule 29 (command -> sety NUMBER .)
    right           reduce using rule 29 (command -> sety NUMBER .)
    rt              reduce using rule 29 (command -> sety NUMBER .)
    back            reduce using rule 29 (command -> sety NUMBER .)
    bk              reduce using rule 29 (command -> sety NUMBER .)
    left            reduce using rule 29 (command -> sety NUMBER .)
    lt              reduce using rule 29 (command -> sety NUMBER .)
    setpos          reduce using rule 29 (command -> sety NUMBER .)
    setxy           reduce using rule 29 (command -> sety NUMBER .)
    setx            reduce using rule 29 (command -> sety NUMBER .)
    sety            reduce using rule 29 (command -> sety NUMBER .)
    home            reduce using rule 29 (command -> sety NUMBER .)
    pendown         reduce using rule 29 (command -> sety NUMBER .)
    pd              reduce using rule 29 (command -> sety NUMBER .)
    penup           reduce using rule 29 (command -> sety NUMBER .)
    pu              reduce using rule 29 (command -> sety NUMBER .)
    setpencolor     reduce using rule 29 (command -> sety NUMBER .)
    make            reduce using rule 29 (command -> sety NUMBER .)
    repeat          reduce using rule 29 (command -> sety NUMBER .)
    while           reduce using rule 29 (command -> sety NUMBER .)
    if              reduce using rule 29 (command -> sety NUMBER .)
    ifelse          reduce using rule 29 (command -> sety NUMBER .)
    TO              reduce using rule 29 (command -> sety NUMBER .)
    STR             reduce using rule 29 (command -> sety NUMBER .)
    $end            reduce using rule 29 (command -> sety NUMBER .)
    ]               reduce using rule 29 (command -> sety NUMBER .)
    END             reduce using rule 29 (command -> sety NUMBER .)


state 51

    (30) command -> sety : . VAR

    VAR             shift and go to state 80


state 52

    (36) command -> setpencolor [ . NUMBER NUMBER NUMBER ]
    (37) command -> setpencolor [ . NUMBER NUMBER : VAR ]
    (38) command -> setpencolor [ . NUMBER : VAR NUMBER ]
    (39) command -> setpencolor [ . NUMBER : VAR : VAR ]
    (40) command -> setpencolor [ . : VAR NUMBER NUMBER ]
    (41) command -> setpencolor [ . : VAR NUMBER : VAR ]
    (42) command -> setpencolor [ . : VAR : VAR NUMBER ]
    (43) command -> setpencolor [ . : VAR : VAR : VAR ]

    NUMBER          shift and go to state 81
    :               shift and go to state 82


state 53

    (44) command -> make " . VAR NUMBER
    (45) command -> make " . VAR : VAR OPERATOR NUMBER
    (46) command -> make " . VAR NUMBER OPERATOR : VAR

    VAR             shift and go to state 83


state 54

    (47) command -> repeat NUMBER . [ program ]

    [               shift and go to state 84


state 55

    (48) command -> repeat : . VAR [ program ]

    VAR             shift and go to state 85


state 56

    (49) command -> while [ . : VAR SIGN NUMBER ] [ program ]

    :               shift and go to state 86


state 57

    (50) command -> if NUMBER . SIGN NUMBER [ program ]
    (52) command -> if NUMBER . SIGN : VAR [ program ]

    SIGN            shift and go to state 87


state 58

    (54) command -> if [ . NUMBER SIGN NUMBER ] [ program ]
    (55) command -> if [ . : VAR SIGN NUMBER ] [ program ]
    (56) command -> if [ . NUMBER SIGN : VAR ] [ program ]
    (57) command -> if [ . : VAR SIGN : VAR ] [ program ]

    NUMBER          shift and go to state 88
    :               shift and go to state 89


state 59

    (51) command -> if : . VAR SIGN NUMBER [ program ]
    (53) command -> if : . VAR SIGN : VAR [ program ]

    VAR             shift and go to state 90


state 60

    (58) command -> ifelse NUMBER . SIGN NUMBER [ program ] [ program ]
    (60) command -> ifelse NUMBER . SIGN : VAR [ program ] [ program ]

    SIGN            shift and go to state 91


state 61

    (62) command -> ifelse [ . NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> ifelse [ . : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> ifelse [ . NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> ifelse [ . : VAR SIGN : VAR ] [ program ] [ program ]

    NUMBER          shift and go to state 92
    :               shift and go to state 93


state 62

    (59) command -> ifelse : . VAR SIGN NUMBER [ program ] [ program ]
    (61) command -> ifelse : . VAR SIGN : VAR [ program ] [ program ]

    VAR             shift and go to state 94


state 63

    (69) command -> TO STR . varlist program END
    (66) varlist -> .
    (67) varlist -> . : VAR
    (68) varlist -> . varlist : VAR

  ! shift/reduce conflict for : resolved as shift
    forward         reduce using rule 66 (varlist -> .)
    fd              reduce using rule 66 (varlist -> .)
    right           reduce using rule 66 (varlist -> .)
    rt              reduce using rule 66 (varlist -> .)
    back            reduce using rule 66 (varlist -> .)
    bk              reduce using rule 66 (varlist -> .)
    left            reduce using rule 66 (varlist -> .)
    lt              reduce using rule 66 (varlist -> .)
    setpos          reduce using rule 66 (varlist -> .)
    setxy           reduce using rule 66 (varlist -> .)
    setx            reduce using rule 66 (varlist -> .)
    sety            reduce using rule 66 (varlist -> .)
    home            reduce using rule 66 (varlist -> .)
    pendown         reduce using rule 66 (varlist -> .)
    pd              reduce using rule 66 (varlist -> .)
    penup           reduce using rule 66 (varlist -> .)
    pu              reduce using rule 66 (varlist -> .)
    setpencolor     reduce using rule 66 (varlist -> .)
    make            reduce using rule 66 (varlist -> .)
    repeat          reduce using rule 66 (varlist -> .)
    while           reduce using rule 66 (varlist -> .)
    if              reduce using rule 66 (varlist -> .)
    ifelse          reduce using rule 66 (varlist -> .)
    TO              reduce using rule 66 (varlist -> .)
    STR             reduce using rule 66 (varlist -> .)
    :               shift and go to state 96

  ! :               [ reduce using rule 66 (varlist -> .) ]

    varlist                        shift and go to state 95

state 64

    (73) command -> STR valuelist .
    (72) valuelist -> valuelist . NUMBER

    forward         reduce using rule 73 (command -> STR valuelist .)
    fd              reduce using rule 73 (command -> STR valuelist .)
    right           reduce using rule 73 (command -> STR valuelist .)
    rt              reduce using rule 73 (command -> STR valuelist .)
    back            reduce using rule 73 (command -> STR valuelist .)
    bk              reduce using rule 73 (command -> STR valuelist .)
    left            reduce using rule 73 (command -> STR valuelist .)
    lt              reduce using rule 73 (command -> STR valuelist .)
    setpos          reduce using rule 73 (command -> STR valuelist .)
    setxy           reduce using rule 73 (command -> STR valuelist .)
    setx            reduce using rule 73 (command -> STR valuelist .)
    sety            reduce using rule 73 (command -> STR valuelist .)
    home            reduce using rule 73 (command -> STR valuelist .)
    pendown         reduce using rule 73 (command -> STR valuelist .)
    pd              reduce using rule 73 (command -> STR valuelist .)
    penup           reduce using rule 73 (command -> STR valuelist .)
    pu              reduce using rule 73 (command -> STR valuelist .)
    setpencolor     reduce using rule 73 (command -> STR valuelist .)
    make            reduce using rule 73 (command -> STR valuelist .)
    repeat          reduce using rule 73 (command -> STR valuelist .)
    while           reduce using rule 73 (command -> STR valuelist .)
    if              reduce using rule 73 (command -> STR valuelist .)
    ifelse          reduce using rule 73 (command -> STR valuelist .)
    TO              reduce using rule 73 (command -> STR valuelist .)
    STR             reduce using rule 73 (command -> STR valuelist .)
    $end            reduce using rule 73 (command -> STR valuelist .)
    ]               reduce using rule 73 (command -> STR valuelist .)
    END             reduce using rule 73 (command -> STR valuelist .)
    NUMBER          shift and go to state 97


state 65

    (71) valuelist -> NUMBER .

    NUMBER          reduce using rule 71 (valuelist -> NUMBER .)
    forward         reduce using rule 71 (valuelist -> NUMBER .)
    fd              reduce using rule 71 (valuelist -> NUMBER .)
    right           reduce using rule 71 (valuelist -> NUMBER .)
    rt              reduce using rule 71 (valuelist -> NUMBER .)
    back            reduce using rule 71 (valuelist -> NUMBER .)
    bk              reduce using rule 71 (valuelist -> NUMBER .)
    left            reduce using rule 71 (valuelist -> NUMBER .)
    lt              reduce using rule 71 (valuelist -> NUMBER .)
    setpos          reduce using rule 71 (valuelist -> NUMBER .)
    setxy           reduce using rule 71 (valuelist -> NUMBER .)
    setx            reduce using rule 71 (valuelist -> NUMBER .)
    sety            reduce using rule 71 (valuelist -> NUMBER .)
    home            reduce using rule 71 (valuelist -> NUMBER .)
    pendown         reduce using rule 71 (valuelist -> NUMBER .)
    pd              reduce using rule 71 (valuelist -> NUMBER .)
    penup           reduce using rule 71 (valuelist -> NUMBER .)
    pu              reduce using rule 71 (valuelist -> NUMBER .)
    setpencolor     reduce using rule 71 (valuelist -> NUMBER .)
    make            reduce using rule 71 (valuelist -> NUMBER .)
    repeat          reduce using rule 71 (valuelist -> NUMBER .)
    while           reduce using rule 71 (valuelist -> NUMBER .)
    if              reduce using rule 71 (valuelist -> NUMBER .)
    ifelse          reduce using rule 71 (valuelist -> NUMBER .)
    TO              reduce using rule 71 (valuelist -> NUMBER .)
    STR             reduce using rule 71 (valuelist -> NUMBER .)
    $end            reduce using rule 71 (valuelist -> NUMBER .)
    ]               reduce using rule 71 (valuelist -> NUMBER .)
    END             reduce using rule 71 (valuelist -> NUMBER .)


state 66

    (5) command -> forward : VAR .

    forward         reduce using rule 5 (command -> forward : VAR .)
    fd              reduce using rule 5 (command -> forward : VAR .)
    right           reduce using rule 5 (command -> forward : VAR .)
    rt              reduce using rule 5 (command -> forward : VAR .)
    back            reduce using rule 5 (command -> forward : VAR .)
    bk              reduce using rule 5 (command -> forward : VAR .)
    left            reduce using rule 5 (command -> forward : VAR .)
    lt              reduce using rule 5 (command -> forward : VAR .)
    setpos          reduce using rule 5 (command -> forward : VAR .)
    setxy           reduce using rule 5 (command -> forward : VAR .)
    setx            reduce using rule 5 (command -> forward : VAR .)
    sety            reduce using rule 5 (command -> forward : VAR .)
    home            reduce using rule 5 (command -> forward : VAR .)
    pendown         reduce using rule 5 (command -> forward : VAR .)
    pd              reduce using rule 5 (command -> forward : VAR .)
    penup           reduce using rule 5 (command -> forward : VAR .)
    pu              reduce using rule 5 (command -> forward : VAR .)
    setpencolor     reduce using rule 5 (command -> forward : VAR .)
    make            reduce using rule 5 (command -> forward : VAR .)
    repeat          reduce using rule 5 (command -> forward : VAR .)
    while           reduce using rule 5 (command -> forward : VAR .)
    if              reduce using rule 5 (command -> forward : VAR .)
    ifelse          reduce using rule 5 (command -> forward : VAR .)
    TO              reduce using rule 5 (command -> forward : VAR .)
    STR             reduce using rule 5 (command -> forward : VAR .)
    $end            reduce using rule 5 (command -> forward : VAR .)
    ]               reduce using rule 5 (command -> forward : VAR .)
    END             reduce using rule 5 (command -> forward : VAR .)


state 67

    (6) command -> fd : VAR .

    forward         reduce using rule 6 (command -> fd : VAR .)
    fd              reduce using rule 6 (command -> fd : VAR .)
    right           reduce using rule 6 (command -> fd : VAR .)
    rt              reduce using rule 6 (command -> fd : VAR .)
    back            reduce using rule 6 (command -> fd : VAR .)
    bk              reduce using rule 6 (command -> fd : VAR .)
    left            reduce using rule 6 (command -> fd : VAR .)
    lt              reduce using rule 6 (command -> fd : VAR .)
    setpos          reduce using rule 6 (command -> fd : VAR .)
    setxy           reduce using rule 6 (command -> fd : VAR .)
    setx            reduce using rule 6 (command -> fd : VAR .)
    sety            reduce using rule 6 (command -> fd : VAR .)
    home            reduce using rule 6 (command -> fd : VAR .)
    pendown         reduce using rule 6 (command -> fd : VAR .)
    pd              reduce using rule 6 (command -> fd : VAR .)
    penup           reduce using rule 6 (command -> fd : VAR .)
    pu              reduce using rule 6 (command -> fd : VAR .)
    setpencolor     reduce using rule 6 (command -> fd : VAR .)
    make            reduce using rule 6 (command -> fd : VAR .)
    repeat          reduce using rule 6 (command -> fd : VAR .)
    while           reduce using rule 6 (command -> fd : VAR .)
    if              reduce using rule 6 (command -> fd : VAR .)
    ifelse          reduce using rule 6 (command -> fd : VAR .)
    TO              reduce using rule 6 (command -> fd : VAR .)
    STR             reduce using rule 6 (command -> fd : VAR .)
    $end            reduce using rule 6 (command -> fd : VAR .)
    ]               reduce using rule 6 (command -> fd : VAR .)
    END             reduce using rule 6 (command -> fd : VAR .)


state 68

    (9) command -> right : VAR .

    forward         reduce using rule 9 (command -> right : VAR .)
    fd              reduce using rule 9 (command -> right : VAR .)
    right           reduce using rule 9 (command -> right : VAR .)
    rt              reduce using rule 9 (command -> right : VAR .)
    back            reduce using rule 9 (command -> right : VAR .)
    bk              reduce using rule 9 (command -> right : VAR .)
    left            reduce using rule 9 (command -> right : VAR .)
    lt              reduce using rule 9 (command -> right : VAR .)
    setpos          reduce using rule 9 (command -> right : VAR .)
    setxy           reduce using rule 9 (command -> right : VAR .)
    setx            reduce using rule 9 (command -> right : VAR .)
    sety            reduce using rule 9 (command -> right : VAR .)
    home            reduce using rule 9 (command -> right : VAR .)
    pendown         reduce using rule 9 (command -> right : VAR .)
    pd              reduce using rule 9 (command -> right : VAR .)
    penup           reduce using rule 9 (command -> right : VAR .)
    pu              reduce using rule 9 (command -> right : VAR .)
    setpencolor     reduce using rule 9 (command -> right : VAR .)
    make            reduce using rule 9 (command -> right : VAR .)
    repeat          reduce using rule 9 (command -> right : VAR .)
    while           reduce using rule 9 (command -> right : VAR .)
    if              reduce using rule 9 (command -> right : VAR .)
    ifelse          reduce using rule 9 (command -> right : VAR .)
    TO              reduce using rule 9 (command -> right : VAR .)
    STR             reduce using rule 9 (command -> right : VAR .)
    $end            reduce using rule 9 (command -> right : VAR .)
    ]               reduce using rule 9 (command -> right : VAR .)
    END             reduce using rule 9 (command -> right : VAR .)


state 69

    (10) command -> rt : VAR .

    forward         reduce using rule 10 (command -> rt : VAR .)
    fd              reduce using rule 10 (command -> rt : VAR .)
    right           reduce using rule 10 (command -> rt : VAR .)
    rt              reduce using rule 10 (command -> rt : VAR .)
    back            reduce using rule 10 (command -> rt : VAR .)
    bk              reduce using rule 10 (command -> rt : VAR .)
    left            reduce using rule 10 (command -> rt : VAR .)
    lt              reduce using rule 10 (command -> rt : VAR .)
    setpos          reduce using rule 10 (command -> rt : VAR .)
    setxy           reduce using rule 10 (command -> rt : VAR .)
    setx            reduce using rule 10 (command -> rt : VAR .)
    sety            reduce using rule 10 (command -> rt : VAR .)
    home            reduce using rule 10 (command -> rt : VAR .)
    pendown         reduce using rule 10 (command -> rt : VAR .)
    pd              reduce using rule 10 (command -> rt : VAR .)
    penup           reduce using rule 10 (command -> rt : VAR .)
    pu              reduce using rule 10 (command -> rt : VAR .)
    setpencolor     reduce using rule 10 (command -> rt : VAR .)
    make            reduce using rule 10 (command -> rt : VAR .)
    repeat          reduce using rule 10 (command -> rt : VAR .)
    while           reduce using rule 10 (command -> rt : VAR .)
    if              reduce using rule 10 (command -> rt : VAR .)
    ifelse          reduce using rule 10 (command -> rt : VAR .)
    TO              reduce using rule 10 (command -> rt : VAR .)
    STR             reduce using rule 10 (command -> rt : VAR .)
    $end            reduce using rule 10 (command -> rt : VAR .)
    ]               reduce using rule 10 (command -> rt : VAR .)
    END             reduce using rule 10 (command -> rt : VAR .)


state 70

    (13) command -> back : VAR .

    forward         reduce using rule 13 (command -> back : VAR .)
    fd              reduce using rule 13 (command -> back : VAR .)
    right           reduce using rule 13 (command -> back : VAR .)
    rt              reduce using rule 13 (command -> back : VAR .)
    back            reduce using rule 13 (command -> back : VAR .)
    bk              reduce using rule 13 (command -> back : VAR .)
    left            reduce using rule 13 (command -> back : VAR .)
    lt              reduce using rule 13 (command -> back : VAR .)
    setpos          reduce using rule 13 (command -> back : VAR .)
    setxy           reduce using rule 13 (command -> back : VAR .)
    setx            reduce using rule 13 (command -> back : VAR .)
    sety            reduce using rule 13 (command -> back : VAR .)
    home            reduce using rule 13 (command -> back : VAR .)
    pendown         reduce using rule 13 (command -> back : VAR .)
    pd              reduce using rule 13 (command -> back : VAR .)
    penup           reduce using rule 13 (command -> back : VAR .)
    pu              reduce using rule 13 (command -> back : VAR .)
    setpencolor     reduce using rule 13 (command -> back : VAR .)
    make            reduce using rule 13 (command -> back : VAR .)
    repeat          reduce using rule 13 (command -> back : VAR .)
    while           reduce using rule 13 (command -> back : VAR .)
    if              reduce using rule 13 (command -> back : VAR .)
    ifelse          reduce using rule 13 (command -> back : VAR .)
    TO              reduce using rule 13 (command -> back : VAR .)
    STR             reduce using rule 13 (command -> back : VAR .)
    $end            reduce using rule 13 (command -> back : VAR .)
    ]               reduce using rule 13 (command -> back : VAR .)
    END             reduce using rule 13 (command -> back : VAR .)


state 71

    (14) command -> bk : VAR .

    forward         reduce using rule 14 (command -> bk : VAR .)
    fd              reduce using rule 14 (command -> bk : VAR .)
    right           reduce using rule 14 (command -> bk : VAR .)
    rt              reduce using rule 14 (command -> bk : VAR .)
    back            reduce using rule 14 (command -> bk : VAR .)
    bk              reduce using rule 14 (command -> bk : VAR .)
    left            reduce using rule 14 (command -> bk : VAR .)
    lt              reduce using rule 14 (command -> bk : VAR .)
    setpos          reduce using rule 14 (command -> bk : VAR .)
    setxy           reduce using rule 14 (command -> bk : VAR .)
    setx            reduce using rule 14 (command -> bk : VAR .)
    sety            reduce using rule 14 (command -> bk : VAR .)
    home            reduce using rule 14 (command -> bk : VAR .)
    pendown         reduce using rule 14 (command -> bk : VAR .)
    pd              reduce using rule 14 (command -> bk : VAR .)
    penup           reduce using rule 14 (command -> bk : VAR .)
    pu              reduce using rule 14 (command -> bk : VAR .)
    setpencolor     reduce using rule 14 (command -> bk : VAR .)
    make            reduce using rule 14 (command -> bk : VAR .)
    repeat          reduce using rule 14 (command -> bk : VAR .)
    while           reduce using rule 14 (command -> bk : VAR .)
    if              reduce using rule 14 (command -> bk : VAR .)
    ifelse          reduce using rule 14 (command -> bk : VAR .)
    TO              reduce using rule 14 (command -> bk : VAR .)
    STR             reduce using rule 14 (command -> bk : VAR .)
    $end            reduce using rule 14 (command -> bk : VAR .)
    ]               reduce using rule 14 (command -> bk : VAR .)
    END             reduce using rule 14 (command -> bk : VAR .)


state 72

    (17) command -> left : VAR .

    forward         reduce using rule 17 (command -> left : VAR .)
    fd              reduce using rule 17 (command -> left : VAR .)
    right           reduce using rule 17 (command -> left : VAR .)
    rt              reduce using rule 17 (command -> left : VAR .)
    back            reduce using rule 17 (command -> left : VAR .)
    bk              reduce using rule 17 (command -> left : VAR .)
    left            reduce using rule 17 (command -> left : VAR .)
    lt              reduce using rule 17 (command -> left : VAR .)
    setpos          reduce using rule 17 (command -> left : VAR .)
    setxy           reduce using rule 17 (command -> left : VAR .)
    setx            reduce using rule 17 (command -> left : VAR .)
    sety            reduce using rule 17 (command -> left : VAR .)
    home            reduce using rule 17 (command -> left : VAR .)
    pendown         reduce using rule 17 (command -> left : VAR .)
    pd              reduce using rule 17 (command -> left : VAR .)
    penup           reduce using rule 17 (command -> left : VAR .)
    pu              reduce using rule 17 (command -> left : VAR .)
    setpencolor     reduce using rule 17 (command -> left : VAR .)
    make            reduce using rule 17 (command -> left : VAR .)
    repeat          reduce using rule 17 (command -> left : VAR .)
    while           reduce using rule 17 (command -> left : VAR .)
    if              reduce using rule 17 (command -> left : VAR .)
    ifelse          reduce using rule 17 (command -> left : VAR .)
    TO              reduce using rule 17 (command -> left : VAR .)
    STR             reduce using rule 17 (command -> left : VAR .)
    $end            reduce using rule 17 (command -> left : VAR .)
    ]               reduce using rule 17 (command -> left : VAR .)
    END             reduce using rule 17 (command -> left : VAR .)


state 73

    (18) command -> lt : VAR .

    forward         reduce using rule 18 (command -> lt : VAR .)
    fd              reduce using rule 18 (command -> lt : VAR .)
    right           reduce using rule 18 (command -> lt : VAR .)
    rt              reduce using rule 18 (command -> lt : VAR .)
    back            reduce using rule 18 (command -> lt : VAR .)
    bk              reduce using rule 18 (command -> lt : VAR .)
    left            reduce using rule 18 (command -> lt : VAR .)
    lt              reduce using rule 18 (command -> lt : VAR .)
    setpos          reduce using rule 18 (command -> lt : VAR .)
    setxy           reduce using rule 18 (command -> lt : VAR .)
    setx            reduce using rule 18 (command -> lt : VAR .)
    sety            reduce using rule 18 (command -> lt : VAR .)
    home            reduce using rule 18 (command -> lt : VAR .)
    pendown         reduce using rule 18 (command -> lt : VAR .)
    pd              reduce using rule 18 (command -> lt : VAR .)
    penup           reduce using rule 18 (command -> lt : VAR .)
    pu              reduce using rule 18 (command -> lt : VAR .)
    setpencolor     reduce using rule 18 (command -> lt : VAR .)
    make            reduce using rule 18 (command -> lt : VAR .)
    repeat          reduce using rule 18 (command -> lt : VAR .)
    while           reduce using rule 18 (command -> lt : VAR .)
    if              reduce using rule 18 (command -> lt : VAR .)
    ifelse          reduce using rule 18 (command -> lt : VAR .)
    TO              reduce using rule 18 (command -> lt : VAR .)
    STR             reduce using rule 18 (command -> lt : VAR .)
    $end            reduce using rule 18 (command -> lt : VAR .)
    ]               reduce using rule 18 (command -> lt : VAR .)
    END             reduce using rule 18 (command -> lt : VAR .)


state 74

    (19) command -> setpos [ NUMBER . NUMBER ]
    (22) command -> setpos [ NUMBER . : VAR ]

    NUMBER          shift and go to state 98
    :               shift and go to state 99


state 75

    (21) command -> setpos [ : . VAR NUMBER ]
    (23) command -> setpos [ : . VAR : VAR ]

    VAR             shift and go to state 100


state 76

    (20) command -> setxy NUMBER NUMBER .

    forward         reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    fd              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    right           reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    rt              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    back            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    bk              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    left            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    lt              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    setpos          reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    setxy           reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    setx            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    sety            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    home            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    pendown         reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    pd              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    penup           reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    pu              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    setpencolor     reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    make            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    repeat          reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    while           reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    if              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    ifelse          reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    TO              reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    STR             reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    $end            reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    ]               reduce using rule 20 (command -> setxy NUMBER NUMBER .)
    END             reduce using rule 20 (command -> setxy NUMBER NUMBER .)


state 77

    (25) command -> setxy NUMBER : . VAR

    VAR             shift and go to state 101


state 78

    (24) command -> setxy : VAR . NUMBER
    (26) command -> setxy : VAR . : VAR

    NUMBER          shift and go to state 103
    :               shift and go to state 102


state 79

    (28) command -> setx : VAR .

    forward         reduce using rule 28 (command -> setx : VAR .)
    fd              reduce using rule 28 (command -> setx : VAR .)
    right           reduce using rule 28 (command -> setx : VAR .)
    rt              reduce using rule 28 (command -> setx : VAR .)
    back            reduce using rule 28 (command -> setx : VAR .)
    bk              reduce using rule 28 (command -> setx : VAR .)
    left            reduce using rule 28 (command -> setx : VAR .)
    lt              reduce using rule 28 (command -> setx : VAR .)
    setpos          reduce using rule 28 (command -> setx : VAR .)
    setxy           reduce using rule 28 (command -> setx : VAR .)
    setx            reduce using rule 28 (command -> setx : VAR .)
    sety            reduce using rule 28 (command -> setx : VAR .)
    home            reduce using rule 28 (command -> setx : VAR .)
    pendown         reduce using rule 28 (command -> setx : VAR .)
    pd              reduce using rule 28 (command -> setx : VAR .)
    penup           reduce using rule 28 (command -> setx : VAR .)
    pu              reduce using rule 28 (command -> setx : VAR .)
    setpencolor     reduce using rule 28 (command -> setx : VAR .)
    make            reduce using rule 28 (command -> setx : VAR .)
    repeat          reduce using rule 28 (command -> setx : VAR .)
    while           reduce using rule 28 (command -> setx : VAR .)
    if              reduce using rule 28 (command -> setx : VAR .)
    ifelse          reduce using rule 28 (command -> setx : VAR .)
    TO              reduce using rule 28 (command -> setx : VAR .)
    STR             reduce using rule 28 (command -> setx : VAR .)
    $end            reduce using rule 28 (command -> setx : VAR .)
    ]               reduce using rule 28 (command -> setx : VAR .)
    END             reduce using rule 28 (command -> setx : VAR .)


state 80

    (30) command -> sety : VAR .

    forward         reduce using rule 30 (command -> sety : VAR .)
    fd              reduce using rule 30 (command -> sety : VAR .)
    right           reduce using rule 30 (command -> sety : VAR .)
    rt              reduce using rule 30 (command -> sety : VAR .)
    back            reduce using rule 30 (command -> sety : VAR .)
    bk              reduce using rule 30 (command -> sety : VAR .)
    left            reduce using rule 30 (command -> sety : VAR .)
    lt              reduce using rule 30 (command -> sety : VAR .)
    setpos          reduce using rule 30 (command -> sety : VAR .)
    setxy           reduce using rule 30 (command -> sety : VAR .)
    setx            reduce using rule 30 (command -> sety : VAR .)
    sety            reduce using rule 30 (command -> sety : VAR .)
    home            reduce using rule 30 (command -> sety : VAR .)
    pendown         reduce using rule 30 (command -> sety : VAR .)
    pd              reduce using rule 30 (command -> sety : VAR .)
    penup           reduce using rule 30 (command -> sety : VAR .)
    pu              reduce using rule 30 (command -> sety : VAR .)
    setpencolor     reduce using rule 30 (command -> sety : VAR .)
    make            reduce using rule 30 (command -> sety : VAR .)
    repeat          reduce using rule 30 (command -> sety : VAR .)
    while           reduce using rule 30 (command -> sety : VAR .)
    if              reduce using rule 30 (command -> sety : VAR .)
    ifelse          reduce using rule 30 (command -> sety : VAR .)
    TO              reduce using rule 30 (command -> sety : VAR .)
    STR             reduce using rule 30 (command -> sety : VAR .)
    $end            reduce using rule 30 (command -> sety : VAR .)
    ]               reduce using rule 30 (command -> sety : VAR .)
    END             reduce using rule 30 (command -> sety : VAR .)


state 81

    (36) command -> setpencolor [ NUMBER . NUMBER NUMBER ]
    (37) command -> setpencolor [ NUMBER . NUMBER : VAR ]
    (38) command -> setpencolor [ NUMBER . : VAR NUMBER ]
    (39) command -> setpencolor [ NUMBER . : VAR : VAR ]

    NUMBER          shift and go to state 104
    :               shift and go to state 105


state 82

    (40) command -> setpencolor [ : . VAR NUMBER NUMBER ]
    (41) command -> setpencolor [ : . VAR NUMBER : VAR ]
    (42) command -> setpencolor [ : . VAR : VAR NUMBER ]
    (43) command -> setpencolor [ : . VAR : VAR : VAR ]

    VAR             shift and go to state 106


state 83

    (44) command -> make " VAR . NUMBER
    (45) command -> make " VAR . : VAR OPERATOR NUMBER
    (46) command -> make " VAR . NUMBER OPERATOR : VAR

    NUMBER          shift and go to state 107
    :               shift and go to state 108


state 84

    (47) command -> repeat NUMBER [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 109
    command                        shift and go to state 2

state 85

    (48) command -> repeat : VAR . [ program ]

    [               shift and go to state 110


state 86

    (49) command -> while [ : . VAR SIGN NUMBER ] [ program ]

    VAR             shift and go to state 111


state 87

    (50) command -> if NUMBER SIGN . NUMBER [ program ]
    (52) command -> if NUMBER SIGN . : VAR [ program ]

    NUMBER          shift and go to state 112
    :               shift and go to state 113


state 88

    (54) command -> if [ NUMBER . SIGN NUMBER ] [ program ]
    (56) command -> if [ NUMBER . SIGN : VAR ] [ program ]

    SIGN            shift and go to state 114


state 89

    (55) command -> if [ : . VAR SIGN NUMBER ] [ program ]
    (57) command -> if [ : . VAR SIGN : VAR ] [ program ]

    VAR             shift and go to state 115


state 90

    (51) command -> if : VAR . SIGN NUMBER [ program ]
    (53) command -> if : VAR . SIGN : VAR [ program ]

    SIGN            shift and go to state 116


state 91

    (58) command -> ifelse NUMBER SIGN . NUMBER [ program ] [ program ]
    (60) command -> ifelse NUMBER SIGN . : VAR [ program ] [ program ]

    NUMBER          shift and go to state 117
    :               shift and go to state 118


state 92

    (62) command -> ifelse [ NUMBER . SIGN NUMBER ] [ program ] [ program ]
    (64) command -> ifelse [ NUMBER . SIGN : VAR ] [ program ] [ program ]

    SIGN            shift and go to state 119


state 93

    (63) command -> ifelse [ : . VAR SIGN NUMBER ] [ program ] [ program ]
    (65) command -> ifelse [ : . VAR SIGN : VAR ] [ program ] [ program ]

    VAR             shift and go to state 120


state 94

    (59) command -> ifelse : VAR . SIGN NUMBER [ program ] [ program ]
    (61) command -> ifelse : VAR . SIGN : VAR [ program ] [ program ]

    SIGN            shift and go to state 121


state 95

    (69) command -> TO STR varlist . program END
    (68) varlist -> varlist . : VAR
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    :               shift and go to state 123
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 122
    command                        shift and go to state 2

state 96

    (67) varlist -> : . VAR

    VAR             shift and go to state 124


state 97

    (72) valuelist -> valuelist NUMBER .

    NUMBER          reduce using rule 72 (valuelist -> valuelist NUMBER .)
    forward         reduce using rule 72 (valuelist -> valuelist NUMBER .)
    fd              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    right           reduce using rule 72 (valuelist -> valuelist NUMBER .)
    rt              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    back            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    bk              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    left            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    lt              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    setpos          reduce using rule 72 (valuelist -> valuelist NUMBER .)
    setxy           reduce using rule 72 (valuelist -> valuelist NUMBER .)
    setx            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    sety            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    home            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    pendown         reduce using rule 72 (valuelist -> valuelist NUMBER .)
    pd              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    penup           reduce using rule 72 (valuelist -> valuelist NUMBER .)
    pu              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    setpencolor     reduce using rule 72 (valuelist -> valuelist NUMBER .)
    make            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    repeat          reduce using rule 72 (valuelist -> valuelist NUMBER .)
    while           reduce using rule 72 (valuelist -> valuelist NUMBER .)
    if              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    ifelse          reduce using rule 72 (valuelist -> valuelist NUMBER .)
    TO              reduce using rule 72 (valuelist -> valuelist NUMBER .)
    STR             reduce using rule 72 (valuelist -> valuelist NUMBER .)
    $end            reduce using rule 72 (valuelist -> valuelist NUMBER .)
    ]               reduce using rule 72 (valuelist -> valuelist NUMBER .)
    END             reduce using rule 72 (valuelist -> valuelist NUMBER .)


state 98

    (19) command -> setpos [ NUMBER NUMBER . ]

    ]               shift and go to state 125


state 99

    (22) command -> setpos [ NUMBER : . VAR ]

    VAR             shift and go to state 126


state 100

    (21) command -> setpos [ : VAR . NUMBER ]
    (23) command -> setpos [ : VAR . : VAR ]

    NUMBER          shift and go to state 128
    :               shift and go to state 127


state 101

    (25) command -> setxy NUMBER : VAR .

    forward         reduce using rule 25 (command -> setxy NUMBER : VAR .)
    fd              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    right           reduce using rule 25 (command -> setxy NUMBER : VAR .)
    rt              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    back            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    bk              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    left            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    lt              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    setpos          reduce using rule 25 (command -> setxy NUMBER : VAR .)
    setxy           reduce using rule 25 (command -> setxy NUMBER : VAR .)
    setx            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    sety            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    home            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    pendown         reduce using rule 25 (command -> setxy NUMBER : VAR .)
    pd              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    penup           reduce using rule 25 (command -> setxy NUMBER : VAR .)
    pu              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    setpencolor     reduce using rule 25 (command -> setxy NUMBER : VAR .)
    make            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    repeat          reduce using rule 25 (command -> setxy NUMBER : VAR .)
    while           reduce using rule 25 (command -> setxy NUMBER : VAR .)
    if              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    ifelse          reduce using rule 25 (command -> setxy NUMBER : VAR .)
    TO              reduce using rule 25 (command -> setxy NUMBER : VAR .)
    STR             reduce using rule 25 (command -> setxy NUMBER : VAR .)
    $end            reduce using rule 25 (command -> setxy NUMBER : VAR .)
    ]               reduce using rule 25 (command -> setxy NUMBER : VAR .)
    END             reduce using rule 25 (command -> setxy NUMBER : VAR .)


state 102

    (26) command -> setxy : VAR : . VAR

    VAR             shift and go to state 129


state 103

    (24) command -> setxy : VAR NUMBER .

    forward         reduce using rule 24 (command -> setxy : VAR NUMBER .)
    fd              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    right           reduce using rule 24 (command -> setxy : VAR NUMBER .)
    rt              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    back            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    bk              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    left            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    lt              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    setpos          reduce using rule 24 (command -> setxy : VAR NUMBER .)
    setxy           reduce using rule 24 (command -> setxy : VAR NUMBER .)
    setx            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    sety            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    home            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    pendown         reduce using rule 24 (command -> setxy : VAR NUMBER .)
    pd              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    penup           reduce using rule 24 (command -> setxy : VAR NUMBER .)
    pu              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    setpencolor     reduce using rule 24 (command -> setxy : VAR NUMBER .)
    make            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    repeat          reduce using rule 24 (command -> setxy : VAR NUMBER .)
    while           reduce using rule 24 (command -> setxy : VAR NUMBER .)
    if              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    ifelse          reduce using rule 24 (command -> setxy : VAR NUMBER .)
    TO              reduce using rule 24 (command -> setxy : VAR NUMBER .)
    STR             reduce using rule 24 (command -> setxy : VAR NUMBER .)
    $end            reduce using rule 24 (command -> setxy : VAR NUMBER .)
    ]               reduce using rule 24 (command -> setxy : VAR NUMBER .)
    END             reduce using rule 24 (command -> setxy : VAR NUMBER .)


state 104

    (36) command -> setpencolor [ NUMBER NUMBER . NUMBER ]
    (37) command -> setpencolor [ NUMBER NUMBER . : VAR ]

    NUMBER          shift and go to state 130
    :               shift and go to state 131


state 105

    (38) command -> setpencolor [ NUMBER : . VAR NUMBER ]
    (39) command -> setpencolor [ NUMBER : . VAR : VAR ]

    VAR             shift and go to state 132


state 106

    (40) command -> setpencolor [ : VAR . NUMBER NUMBER ]
    (41) command -> setpencolor [ : VAR . NUMBER : VAR ]
    (42) command -> setpencolor [ : VAR . : VAR NUMBER ]
    (43) command -> setpencolor [ : VAR . : VAR : VAR ]

    NUMBER          shift and go to state 134
    :               shift and go to state 133


state 107

    (44) command -> make " VAR NUMBER .
    (46) command -> make " VAR NUMBER . OPERATOR : VAR

    forward         reduce using rule 44 (command -> make " VAR NUMBER .)
    fd              reduce using rule 44 (command -> make " VAR NUMBER .)
    right           reduce using rule 44 (command -> make " VAR NUMBER .)
    rt              reduce using rule 44 (command -> make " VAR NUMBER .)
    back            reduce using rule 44 (command -> make " VAR NUMBER .)
    bk              reduce using rule 44 (command -> make " VAR NUMBER .)
    left            reduce using rule 44 (command -> make " VAR NUMBER .)
    lt              reduce using rule 44 (command -> make " VAR NUMBER .)
    setpos          reduce using rule 44 (command -> make " VAR NUMBER .)
    setxy           reduce using rule 44 (command -> make " VAR NUMBER .)
    setx            reduce using rule 44 (command -> make " VAR NUMBER .)
    sety            reduce using rule 44 (command -> make " VAR NUMBER .)
    home            reduce using rule 44 (command -> make " VAR NUMBER .)
    pendown         reduce using rule 44 (command -> make " VAR NUMBER .)
    pd              reduce using rule 44 (command -> make " VAR NUMBER .)
    penup           reduce using rule 44 (command -> make " VAR NUMBER .)
    pu              reduce using rule 44 (command -> make " VAR NUMBER .)
    setpencolor     reduce using rule 44 (command -> make " VAR NUMBER .)
    make            reduce using rule 44 (command -> make " VAR NUMBER .)
    repeat          reduce using rule 44 (command -> make " VAR NUMBER .)
    while           reduce using rule 44 (command -> make " VAR NUMBER .)
    if              reduce using rule 44 (command -> make " VAR NUMBER .)
    ifelse          reduce using rule 44 (command -> make " VAR NUMBER .)
    TO              reduce using rule 44 (command -> make " VAR NUMBER .)
    STR             reduce using rule 44 (command -> make " VAR NUMBER .)
    $end            reduce using rule 44 (command -> make " VAR NUMBER .)
    ]               reduce using rule 44 (command -> make " VAR NUMBER .)
    END             reduce using rule 44 (command -> make " VAR NUMBER .)
    OPERATOR        shift and go to state 135


state 108

    (45) command -> make " VAR : . VAR OPERATOR NUMBER

    VAR             shift and go to state 136


state 109

    (47) command -> repeat NUMBER [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 137
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 110

    (48) command -> repeat : VAR [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 138
    command                        shift and go to state 2

state 111

    (49) command -> while [ : VAR . SIGN NUMBER ] [ program ]

    SIGN            shift and go to state 139


state 112

    (50) command -> if NUMBER SIGN NUMBER . [ program ]

    [               shift and go to state 140


state 113

    (52) command -> if NUMBER SIGN : . VAR [ program ]

    VAR             shift and go to state 141


state 114

    (54) command -> if [ NUMBER SIGN . NUMBER ] [ program ]
    (56) command -> if [ NUMBER SIGN . : VAR ] [ program ]

    NUMBER          shift and go to state 142
    :               shift and go to state 143


state 115

    (55) command -> if [ : VAR . SIGN NUMBER ] [ program ]
    (57) command -> if [ : VAR . SIGN : VAR ] [ program ]

    SIGN            shift and go to state 144


state 116

    (51) command -> if : VAR SIGN . NUMBER [ program ]
    (53) command -> if : VAR SIGN . : VAR [ program ]

    NUMBER          shift and go to state 146
    :               shift and go to state 145


state 117

    (58) command -> ifelse NUMBER SIGN NUMBER . [ program ] [ program ]

    [               shift and go to state 147


state 118

    (60) command -> ifelse NUMBER SIGN : . VAR [ program ] [ program ]

    VAR             shift and go to state 148


state 119

    (62) command -> ifelse [ NUMBER SIGN . NUMBER ] [ program ] [ program ]
    (64) command -> ifelse [ NUMBER SIGN . : VAR ] [ program ] [ program ]

    NUMBER          shift and go to state 149
    :               shift and go to state 150


state 120

    (63) command -> ifelse [ : VAR . SIGN NUMBER ] [ program ] [ program ]
    (65) command -> ifelse [ : VAR . SIGN : VAR ] [ program ] [ program ]

    SIGN            shift and go to state 151


state 121

    (59) command -> ifelse : VAR SIGN . NUMBER [ program ] [ program ]
    (61) command -> ifelse : VAR SIGN . : VAR [ program ] [ program ]

    NUMBER          shift and go to state 153
    :               shift and go to state 152


state 122

    (69) command -> TO STR varlist program . END
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    END             shift and go to state 154
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 123

    (68) varlist -> varlist : . VAR

    VAR             shift and go to state 155


state 124

    (67) varlist -> : VAR .

    :               reduce using rule 67 (varlist -> : VAR .)
    forward         reduce using rule 67 (varlist -> : VAR .)
    fd              reduce using rule 67 (varlist -> : VAR .)
    right           reduce using rule 67 (varlist -> : VAR .)
    rt              reduce using rule 67 (varlist -> : VAR .)
    back            reduce using rule 67 (varlist -> : VAR .)
    bk              reduce using rule 67 (varlist -> : VAR .)
    left            reduce using rule 67 (varlist -> : VAR .)
    lt              reduce using rule 67 (varlist -> : VAR .)
    setpos          reduce using rule 67 (varlist -> : VAR .)
    setxy           reduce using rule 67 (varlist -> : VAR .)
    setx            reduce using rule 67 (varlist -> : VAR .)
    sety            reduce using rule 67 (varlist -> : VAR .)
    home            reduce using rule 67 (varlist -> : VAR .)
    pendown         reduce using rule 67 (varlist -> : VAR .)
    pd              reduce using rule 67 (varlist -> : VAR .)
    penup           reduce using rule 67 (varlist -> : VAR .)
    pu              reduce using rule 67 (varlist -> : VAR .)
    setpencolor     reduce using rule 67 (varlist -> : VAR .)
    make            reduce using rule 67 (varlist -> : VAR .)
    repeat          reduce using rule 67 (varlist -> : VAR .)
    while           reduce using rule 67 (varlist -> : VAR .)
    if              reduce using rule 67 (varlist -> : VAR .)
    ifelse          reduce using rule 67 (varlist -> : VAR .)
    TO              reduce using rule 67 (varlist -> : VAR .)
    STR             reduce using rule 67 (varlist -> : VAR .)


state 125

    (19) command -> setpos [ NUMBER NUMBER ] .

    forward         reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    fd              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    right           reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    rt              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    back            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    bk              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    left            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    lt              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    setpos          reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    setxy           reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    setx            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    sety            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    home            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    pendown         reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    pd              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    penup           reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    pu              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    setpencolor     reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    make            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    repeat          reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    while           reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    if              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    ifelse          reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    TO              reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    STR             reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    $end            reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    ]               reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)
    END             reduce using rule 19 (command -> setpos [ NUMBER NUMBER ] .)


state 126

    (22) command -> setpos [ NUMBER : VAR . ]

    ]               shift and go to state 156


state 127

    (23) command -> setpos [ : VAR : . VAR ]

    VAR             shift and go to state 157


state 128

    (21) command -> setpos [ : VAR NUMBER . ]

    ]               shift and go to state 158


state 129

    (26) command -> setxy : VAR : VAR .

    forward         reduce using rule 26 (command -> setxy : VAR : VAR .)
    fd              reduce using rule 26 (command -> setxy : VAR : VAR .)
    right           reduce using rule 26 (command -> setxy : VAR : VAR .)
    rt              reduce using rule 26 (command -> setxy : VAR : VAR .)
    back            reduce using rule 26 (command -> setxy : VAR : VAR .)
    bk              reduce using rule 26 (command -> setxy : VAR : VAR .)
    left            reduce using rule 26 (command -> setxy : VAR : VAR .)
    lt              reduce using rule 26 (command -> setxy : VAR : VAR .)
    setpos          reduce using rule 26 (command -> setxy : VAR : VAR .)
    setxy           reduce using rule 26 (command -> setxy : VAR : VAR .)
    setx            reduce using rule 26 (command -> setxy : VAR : VAR .)
    sety            reduce using rule 26 (command -> setxy : VAR : VAR .)
    home            reduce using rule 26 (command -> setxy : VAR : VAR .)
    pendown         reduce using rule 26 (command -> setxy : VAR : VAR .)
    pd              reduce using rule 26 (command -> setxy : VAR : VAR .)
    penup           reduce using rule 26 (command -> setxy : VAR : VAR .)
    pu              reduce using rule 26 (command -> setxy : VAR : VAR .)
    setpencolor     reduce using rule 26 (command -> setxy : VAR : VAR .)
    make            reduce using rule 26 (command -> setxy : VAR : VAR .)
    repeat          reduce using rule 26 (command -> setxy : VAR : VAR .)
    while           reduce using rule 26 (command -> setxy : VAR : VAR .)
    if              reduce using rule 26 (command -> setxy : VAR : VAR .)
    ifelse          reduce using rule 26 (command -> setxy : VAR : VAR .)
    TO              reduce using rule 26 (command -> setxy : VAR : VAR .)
    STR             reduce using rule 26 (command -> setxy : VAR : VAR .)
    $end            reduce using rule 26 (command -> setxy : VAR : VAR .)
    ]               reduce using rule 26 (command -> setxy : VAR : VAR .)
    END             reduce using rule 26 (command -> setxy : VAR : VAR .)


state 130

    (36) command -> setpencolor [ NUMBER NUMBER NUMBER . ]

    ]               shift and go to state 159


state 131

    (37) command -> setpencolor [ NUMBER NUMBER : . VAR ]

    VAR             shift and go to state 160


state 132

    (38) command -> setpencolor [ NUMBER : VAR . NUMBER ]
    (39) command -> setpencolor [ NUMBER : VAR . : VAR ]

    NUMBER          shift and go to state 161
    :               shift and go to state 162


state 133

    (42) command -> setpencolor [ : VAR : . VAR NUMBER ]
    (43) command -> setpencolor [ : VAR : . VAR : VAR ]

    VAR             shift and go to state 163


state 134

    (40) command -> setpencolor [ : VAR NUMBER . NUMBER ]
    (41) command -> setpencolor [ : VAR NUMBER . : VAR ]

    NUMBER          shift and go to state 165
    :               shift and go to state 164


state 135

    (46) command -> make " VAR NUMBER OPERATOR . : VAR

    :               shift and go to state 166


state 136

    (45) command -> make " VAR : VAR . OPERATOR NUMBER

    OPERATOR        shift and go to state 167


state 137

    (47) command -> repeat NUMBER [ program ] .

    forward         reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    fd              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    right           reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    rt              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    back            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    bk              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    left            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    lt              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    setpos          reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    setxy           reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    setx            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    sety            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    home            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    pendown         reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    pd              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    penup           reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    pu              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    setpencolor     reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    make            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    repeat          reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    while           reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    if              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    ifelse          reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    TO              reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    STR             reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    $end            reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    ]               reduce using rule 47 (command -> repeat NUMBER [ program ] .)
    END             reduce using rule 47 (command -> repeat NUMBER [ program ] .)


state 138

    (48) command -> repeat : VAR [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 168
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 139

    (49) command -> while [ : VAR SIGN . NUMBER ] [ program ]

    NUMBER          shift and go to state 169


state 140

    (50) command -> if NUMBER SIGN NUMBER [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 170
    command                        shift and go to state 2

state 141

    (52) command -> if NUMBER SIGN : VAR . [ program ]

    [               shift and go to state 171


state 142

    (54) command -> if [ NUMBER SIGN NUMBER . ] [ program ]

    ]               shift and go to state 172


state 143

    (56) command -> if [ NUMBER SIGN : . VAR ] [ program ]

    VAR             shift and go to state 173


state 144

    (55) command -> if [ : VAR SIGN . NUMBER ] [ program ]
    (57) command -> if [ : VAR SIGN . : VAR ] [ program ]

    NUMBER          shift and go to state 175
    :               shift and go to state 174


state 145

    (53) command -> if : VAR SIGN : . VAR [ program ]

    VAR             shift and go to state 176


state 146

    (51) command -> if : VAR SIGN NUMBER . [ program ]

    [               shift and go to state 177


state 147

    (58) command -> ifelse NUMBER SIGN NUMBER [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 178
    command                        shift and go to state 2

state 148

    (60) command -> ifelse NUMBER SIGN : VAR . [ program ] [ program ]

    [               shift and go to state 179


state 149

    (62) command -> ifelse [ NUMBER SIGN NUMBER . ] [ program ] [ program ]

    ]               shift and go to state 180


state 150

    (64) command -> ifelse [ NUMBER SIGN : . VAR ] [ program ] [ program ]

    VAR             shift and go to state 181


state 151

    (63) command -> ifelse [ : VAR SIGN . NUMBER ] [ program ] [ program ]
    (65) command -> ifelse [ : VAR SIGN . : VAR ] [ program ] [ program ]

    NUMBER          shift and go to state 183
    :               shift and go to state 182


state 152

    (61) command -> ifelse : VAR SIGN : . VAR [ program ] [ program ]

    VAR             shift and go to state 184


state 153

    (59) command -> ifelse : VAR SIGN NUMBER . [ program ] [ program ]

    [               shift and go to state 185


state 154

    (69) command -> TO STR varlist program END .

    forward         reduce using rule 69 (command -> TO STR varlist program END .)
    fd              reduce using rule 69 (command -> TO STR varlist program END .)
    right           reduce using rule 69 (command -> TO STR varlist program END .)
    rt              reduce using rule 69 (command -> TO STR varlist program END .)
    back            reduce using rule 69 (command -> TO STR varlist program END .)
    bk              reduce using rule 69 (command -> TO STR varlist program END .)
    left            reduce using rule 69 (command -> TO STR varlist program END .)
    lt              reduce using rule 69 (command -> TO STR varlist program END .)
    setpos          reduce using rule 69 (command -> TO STR varlist program END .)
    setxy           reduce using rule 69 (command -> TO STR varlist program END .)
    setx            reduce using rule 69 (command -> TO STR varlist program END .)
    sety            reduce using rule 69 (command -> TO STR varlist program END .)
    home            reduce using rule 69 (command -> TO STR varlist program END .)
    pendown         reduce using rule 69 (command -> TO STR varlist program END .)
    pd              reduce using rule 69 (command -> TO STR varlist program END .)
    penup           reduce using rule 69 (command -> TO STR varlist program END .)
    pu              reduce using rule 69 (command -> TO STR varlist program END .)
    setpencolor     reduce using rule 69 (command -> TO STR varlist program END .)
    make            reduce using rule 69 (command -> TO STR varlist program END .)
    repeat          reduce using rule 69 (command -> TO STR varlist program END .)
    while           reduce using rule 69 (command -> TO STR varlist program END .)
    if              reduce using rule 69 (command -> TO STR varlist program END .)
    ifelse          reduce using rule 69 (command -> TO STR varlist program END .)
    TO              reduce using rule 69 (command -> TO STR varlist program END .)
    STR             reduce using rule 69 (command -> TO STR varlist program END .)
    $end            reduce using rule 69 (command -> TO STR varlist program END .)
    ]               reduce using rule 69 (command -> TO STR varlist program END .)
    END             reduce using rule 69 (command -> TO STR varlist program END .)


state 155

    (68) varlist -> varlist : VAR .

    :               reduce using rule 68 (varlist -> varlist : VAR .)
    forward         reduce using rule 68 (varlist -> varlist : VAR .)
    fd              reduce using rule 68 (varlist -> varlist : VAR .)
    right           reduce using rule 68 (varlist -> varlist : VAR .)
    rt              reduce using rule 68 (varlist -> varlist : VAR .)
    back            reduce using rule 68 (varlist -> varlist : VAR .)
    bk              reduce using rule 68 (varlist -> varlist : VAR .)
    left            reduce using rule 68 (varlist -> varlist : VAR .)
    lt              reduce using rule 68 (varlist -> varlist : VAR .)
    setpos          reduce using rule 68 (varlist -> varlist : VAR .)
    setxy           reduce using rule 68 (varlist -> varlist : VAR .)
    setx            reduce using rule 68 (varlist -> varlist : VAR .)
    sety            reduce using rule 68 (varlist -> varlist : VAR .)
    home            reduce using rule 68 (varlist -> varlist : VAR .)
    pendown         reduce using rule 68 (varlist -> varlist : VAR .)
    pd              reduce using rule 68 (varlist -> varlist : VAR .)
    penup           reduce using rule 68 (varlist -> varlist : VAR .)
    pu              reduce using rule 68 (varlist -> varlist : VAR .)
    setpencolor     reduce using rule 68 (varlist -> varlist : VAR .)
    make            reduce using rule 68 (varlist -> varlist : VAR .)
    repeat          reduce using rule 68 (varlist -> varlist : VAR .)
    while           reduce using rule 68 (varlist -> varlist : VAR .)
    if              reduce using rule 68 (varlist -> varlist : VAR .)
    ifelse          reduce using rule 68 (varlist -> varlist : VAR .)
    TO              reduce using rule 68 (varlist -> varlist : VAR .)
    STR             reduce using rule 68 (varlist -> varlist : VAR .)


state 156

    (22) command -> setpos [ NUMBER : VAR ] .

    forward         reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    fd              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    right           reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    rt              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    back            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    bk              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    left            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    lt              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    setpos          reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    setxy           reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    setx            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    sety            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    home            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    pendown         reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    pd              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    penup           reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    pu              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    setpencolor     reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    make            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    repeat          reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    while           reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    if              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    ifelse          reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    TO              reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    STR             reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    $end            reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    ]               reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)
    END             reduce using rule 22 (command -> setpos [ NUMBER : VAR ] .)


state 157

    (23) command -> setpos [ : VAR : VAR . ]

    ]               shift and go to state 186


state 158

    (21) command -> setpos [ : VAR NUMBER ] .

    forward         reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    fd              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    right           reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    rt              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    back            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    bk              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    left            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    lt              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    setpos          reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    setxy           reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    setx            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    sety            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    home            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    pendown         reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    pd              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    penup           reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    pu              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    setpencolor     reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    make            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    repeat          reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    while           reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    if              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    ifelse          reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    TO              reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    STR             reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    $end            reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    ]               reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)
    END             reduce using rule 21 (command -> setpos [ : VAR NUMBER ] .)


state 159

    (36) command -> setpencolor [ NUMBER NUMBER NUMBER ] .

    forward         reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    fd              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    right           reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    rt              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    back            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    bk              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    left            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    lt              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    setpos          reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    setxy           reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    setx            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    sety            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    home            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    pendown         reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    pd              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    penup           reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    pu              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    setpencolor     reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    make            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    repeat          reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    while           reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    if              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    ifelse          reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    TO              reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    STR             reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    $end            reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    ]               reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)
    END             reduce using rule 36 (command -> setpencolor [ NUMBER NUMBER NUMBER ] .)


state 160

    (37) command -> setpencolor [ NUMBER NUMBER : VAR . ]

    ]               shift and go to state 187


state 161

    (38) command -> setpencolor [ NUMBER : VAR NUMBER . ]

    ]               shift and go to state 188


state 162

    (39) command -> setpencolor [ NUMBER : VAR : . VAR ]

    VAR             shift and go to state 189


state 163

    (42) command -> setpencolor [ : VAR : VAR . NUMBER ]
    (43) command -> setpencolor [ : VAR : VAR . : VAR ]

    NUMBER          shift and go to state 191
    :               shift and go to state 190


state 164

    (41) command -> setpencolor [ : VAR NUMBER : . VAR ]

    VAR             shift and go to state 192


state 165

    (40) command -> setpencolor [ : VAR NUMBER NUMBER . ]

    ]               shift and go to state 193


state 166

    (46) command -> make " VAR NUMBER OPERATOR : . VAR

    VAR             shift and go to state 194


state 167

    (45) command -> make " VAR : VAR OPERATOR . NUMBER

    NUMBER          shift and go to state 195


state 168

    (48) command -> repeat : VAR [ program ] .

    forward         reduce using rule 48 (command -> repeat : VAR [ program ] .)
    fd              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    right           reduce using rule 48 (command -> repeat : VAR [ program ] .)
    rt              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    back            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    bk              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    left            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    lt              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    setpos          reduce using rule 48 (command -> repeat : VAR [ program ] .)
    setxy           reduce using rule 48 (command -> repeat : VAR [ program ] .)
    setx            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    sety            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    home            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    pendown         reduce using rule 48 (command -> repeat : VAR [ program ] .)
    pd              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    penup           reduce using rule 48 (command -> repeat : VAR [ program ] .)
    pu              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    setpencolor     reduce using rule 48 (command -> repeat : VAR [ program ] .)
    make            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    repeat          reduce using rule 48 (command -> repeat : VAR [ program ] .)
    while           reduce using rule 48 (command -> repeat : VAR [ program ] .)
    if              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    ifelse          reduce using rule 48 (command -> repeat : VAR [ program ] .)
    TO              reduce using rule 48 (command -> repeat : VAR [ program ] .)
    STR             reduce using rule 48 (command -> repeat : VAR [ program ] .)
    $end            reduce using rule 48 (command -> repeat : VAR [ program ] .)
    ]               reduce using rule 48 (command -> repeat : VAR [ program ] .)
    END             reduce using rule 48 (command -> repeat : VAR [ program ] .)


state 169

    (49) command -> while [ : VAR SIGN NUMBER . ] [ program ]

    ]               shift and go to state 196


state 170

    (50) command -> if NUMBER SIGN NUMBER [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 197
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 171

    (52) command -> if NUMBER SIGN : VAR [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 198
    command                        shift and go to state 2

state 172

    (54) command -> if [ NUMBER SIGN NUMBER ] . [ program ]

    [               shift and go to state 199


state 173

    (56) command -> if [ NUMBER SIGN : VAR . ] [ program ]

    ]               shift and go to state 200


state 174

    (57) command -> if [ : VAR SIGN : . VAR ] [ program ]

    VAR             shift and go to state 201


state 175

    (55) command -> if [ : VAR SIGN NUMBER . ] [ program ]

    ]               shift and go to state 202


state 176

    (53) command -> if : VAR SIGN : VAR . [ program ]

    [               shift and go to state 203


state 177

    (51) command -> if : VAR SIGN NUMBER [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 204
    command                        shift and go to state 2

state 178

    (58) command -> ifelse NUMBER SIGN NUMBER [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 205
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 179

    (60) command -> ifelse NUMBER SIGN : VAR [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 206
    command                        shift and go to state 2

state 180

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] . [ program ] [ program ]

    [               shift and go to state 207


state 181

    (64) command -> ifelse [ NUMBER SIGN : VAR . ] [ program ] [ program ]

    ]               shift and go to state 208


state 182

    (65) command -> ifelse [ : VAR SIGN : . VAR ] [ program ] [ program ]

    VAR             shift and go to state 209


state 183

    (63) command -> ifelse [ : VAR SIGN NUMBER . ] [ program ] [ program ]

    ]               shift and go to state 210


state 184

    (61) command -> ifelse : VAR SIGN : VAR . [ program ] [ program ]

    [               shift and go to state 211


state 185

    (59) command -> ifelse : VAR SIGN NUMBER [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 212
    command                        shift and go to state 2

state 186

    (23) command -> setpos [ : VAR : VAR ] .

    forward         reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    fd              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    right           reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    rt              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    back            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    bk              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    left            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    lt              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    setpos          reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    setxy           reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    setx            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    sety            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    home            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    pendown         reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    pd              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    penup           reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    pu              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    setpencolor     reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    make            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    repeat          reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    while           reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    if              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    ifelse          reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    TO              reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    STR             reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    $end            reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    ]               reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)
    END             reduce using rule 23 (command -> setpos [ : VAR : VAR ] .)


state 187

    (37) command -> setpencolor [ NUMBER NUMBER : VAR ] .

    forward         reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    fd              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    right           reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    rt              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    back            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    bk              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    left            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    lt              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    setpos          reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    setxy           reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    setx            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    sety            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    home            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    pendown         reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    pd              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    penup           reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    pu              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    setpencolor     reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    make            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    repeat          reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    while           reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    if              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    ifelse          reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    TO              reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    STR             reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    $end            reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    ]               reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)
    END             reduce using rule 37 (command -> setpencolor [ NUMBER NUMBER : VAR ] .)


state 188

    (38) command -> setpencolor [ NUMBER : VAR NUMBER ] .

    forward         reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    fd              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    right           reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    rt              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    back            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    bk              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    left            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    lt              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    setpos          reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    setxy           reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    setx            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    sety            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    home            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    pendown         reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    pd              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    penup           reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    pu              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    setpencolor     reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    make            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    repeat          reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    while           reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    if              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    ifelse          reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    TO              reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    STR             reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    $end            reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    ]               reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)
    END             reduce using rule 38 (command -> setpencolor [ NUMBER : VAR NUMBER ] .)


state 189

    (39) command -> setpencolor [ NUMBER : VAR : VAR . ]

    ]               shift and go to state 213


state 190

    (43) command -> setpencolor [ : VAR : VAR : . VAR ]

    VAR             shift and go to state 214


state 191

    (42) command -> setpencolor [ : VAR : VAR NUMBER . ]

    ]               shift and go to state 215


state 192

    (41) command -> setpencolor [ : VAR NUMBER : VAR . ]

    ]               shift and go to state 216


state 193

    (40) command -> setpencolor [ : VAR NUMBER NUMBER ] .

    forward         reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    fd              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    right           reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    rt              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    back            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    bk              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    left            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    lt              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    setpos          reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    setxy           reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    setx            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    sety            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    home            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    pendown         reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    pd              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    penup           reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    pu              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    setpencolor     reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    make            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    repeat          reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    while           reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    if              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    ifelse          reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    TO              reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    STR             reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    $end            reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    ]               reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)
    END             reduce using rule 40 (command -> setpencolor [ : VAR NUMBER NUMBER ] .)


state 194

    (46) command -> make " VAR NUMBER OPERATOR : VAR .

    forward         reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    fd              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    right           reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    rt              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    back            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    bk              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    left            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    lt              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    setpos          reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    setxy           reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    setx            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    sety            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    home            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    pendown         reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    pd              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    penup           reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    pu              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    setpencolor     reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    make            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    repeat          reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    while           reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    if              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    ifelse          reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    TO              reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    STR             reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    $end            reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    ]               reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)
    END             reduce using rule 46 (command -> make " VAR NUMBER OPERATOR : VAR .)


state 195

    (45) command -> make " VAR : VAR OPERATOR NUMBER .

    forward         reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    fd              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    right           reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    rt              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    back            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    bk              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    left            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    lt              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    setpos          reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    setxy           reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    setx            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    sety            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    home            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    pendown         reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    pd              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    penup           reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    pu              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    setpencolor     reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    make            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    repeat          reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    while           reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    if              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    ifelse          reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    TO              reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    STR             reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    $end            reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    ]               reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)
    END             reduce using rule 45 (command -> make " VAR : VAR OPERATOR NUMBER .)


state 196

    (49) command -> while [ : VAR SIGN NUMBER ] . [ program ]

    [               shift and go to state 217


state 197

    (50) command -> if NUMBER SIGN NUMBER [ program ] .

    forward         reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    fd              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    right           reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    rt              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    back            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    bk              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    left            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    lt              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    setpos          reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    setxy           reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    setx            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    sety            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    home            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    pendown         reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    pd              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    penup           reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    pu              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    setpencolor     reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    make            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    repeat          reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    while           reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    if              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    ifelse          reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    TO              reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    STR             reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    $end            reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    ]               reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)
    END             reduce using rule 50 (command -> if NUMBER SIGN NUMBER [ program ] .)


state 198

    (52) command -> if NUMBER SIGN : VAR [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 218
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 199

    (54) command -> if [ NUMBER SIGN NUMBER ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 219
    command                        shift and go to state 2

state 200

    (56) command -> if [ NUMBER SIGN : VAR ] . [ program ]

    [               shift and go to state 220


state 201

    (57) command -> if [ : VAR SIGN : VAR . ] [ program ]

    ]               shift and go to state 221


state 202

    (55) command -> if [ : VAR SIGN NUMBER ] . [ program ]

    [               shift and go to state 222


state 203

    (53) command -> if : VAR SIGN : VAR [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 223
    command                        shift and go to state 2

state 204

    (51) command -> if : VAR SIGN NUMBER [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 224
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 205

    (58) command -> ifelse NUMBER SIGN NUMBER [ program ] . [ program ]

    [               shift and go to state 225


state 206

    (60) command -> ifelse NUMBER SIGN : VAR [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 226
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 207

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 227
    command                        shift and go to state 2

state 208

    (64) command -> ifelse [ NUMBER SIGN : VAR ] . [ program ] [ program ]

    [               shift and go to state 228


state 209

    (65) command -> ifelse [ : VAR SIGN : VAR . ] [ program ] [ program ]

    ]               shift and go to state 229


state 210

    (63) command -> ifelse [ : VAR SIGN NUMBER ] . [ program ] [ program ]

    [               shift and go to state 230


state 211

    (61) command -> ifelse : VAR SIGN : VAR [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 231
    command                        shift and go to state 2

state 212

    (59) command -> ifelse : VAR SIGN NUMBER [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 232
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 213

    (39) command -> setpencolor [ NUMBER : VAR : VAR ] .

    forward         reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    fd              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    right           reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    rt              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    back            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    bk              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    left            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    lt              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    setpos          reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    setxy           reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    setx            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    sety            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    home            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    pendown         reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    pd              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    penup           reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    pu              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    setpencolor     reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    make            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    repeat          reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    while           reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    if              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    ifelse          reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    TO              reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    STR             reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    $end            reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    ]               reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)
    END             reduce using rule 39 (command -> setpencolor [ NUMBER : VAR : VAR ] .)


state 214

    (43) command -> setpencolor [ : VAR : VAR : VAR . ]

    ]               shift and go to state 233


state 215

    (42) command -> setpencolor [ : VAR : VAR NUMBER ] .

    forward         reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    fd              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    right           reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    rt              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    back            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    bk              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    left            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    lt              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    setpos          reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    setxy           reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    setx            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    sety            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    home            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    pendown         reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    pd              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    penup           reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    pu              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    setpencolor     reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    make            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    repeat          reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    while           reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    if              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    ifelse          reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    TO              reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    STR             reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    $end            reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    ]               reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)
    END             reduce using rule 42 (command -> setpencolor [ : VAR : VAR NUMBER ] .)


state 216

    (41) command -> setpencolor [ : VAR NUMBER : VAR ] .

    forward         reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    fd              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    right           reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    rt              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    back            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    bk              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    left            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    lt              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    setpos          reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    setxy           reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    setx            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    sety            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    home            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    pendown         reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    pd              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    penup           reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    pu              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    setpencolor     reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    make            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    repeat          reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    while           reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    if              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    ifelse          reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    TO              reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    STR             reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    $end            reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    ]               reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)
    END             reduce using rule 41 (command -> setpencolor [ : VAR NUMBER : VAR ] .)


state 217

    (49) command -> while [ : VAR SIGN NUMBER ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 234
    command                        shift and go to state 2

state 218

    (52) command -> if NUMBER SIGN : VAR [ program ] .

    forward         reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    fd              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    right           reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    rt              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    back            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    bk              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    left            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    lt              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    setpos          reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    setxy           reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    setx            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    sety            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    home            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    pendown         reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    pd              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    penup           reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    pu              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    setpencolor     reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    make            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    repeat          reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    while           reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    if              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    ifelse          reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    TO              reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    STR             reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    $end            reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    ]               reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)
    END             reduce using rule 52 (command -> if NUMBER SIGN : VAR [ program ] .)


state 219

    (54) command -> if [ NUMBER SIGN NUMBER ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 235
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 220

    (56) command -> if [ NUMBER SIGN : VAR ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 236
    command                        shift and go to state 2

state 221

    (57) command -> if [ : VAR SIGN : VAR ] . [ program ]

    [               shift and go to state 237


state 222

    (55) command -> if [ : VAR SIGN NUMBER ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 238
    command                        shift and go to state 2

state 223

    (53) command -> if : VAR SIGN : VAR [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 239
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 224

    (51) command -> if : VAR SIGN NUMBER [ program ] .

    forward         reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    fd              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    right           reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    rt              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    back            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    bk              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    left            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    lt              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    setpos          reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    setxy           reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    setx            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    sety            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    home            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    pendown         reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    pd              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    penup           reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    pu              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    setpencolor     reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    make            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    repeat          reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    while           reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    if              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    ifelse          reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    TO              reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    STR             reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    $end            reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    ]               reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)
    END             reduce using rule 51 (command -> if : VAR SIGN NUMBER [ program ] .)


state 225

    (58) command -> ifelse NUMBER SIGN NUMBER [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 240
    command                        shift and go to state 2

state 226

    (60) command -> ifelse NUMBER SIGN : VAR [ program ] . [ program ]

    [               shift and go to state 241


state 227

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 242
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 228

    (64) command -> ifelse [ NUMBER SIGN : VAR ] [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 243
    command                        shift and go to state 2

state 229

    (65) command -> ifelse [ : VAR SIGN : VAR ] . [ program ] [ program ]

    [               shift and go to state 244


state 230

    (63) command -> ifelse [ : VAR SIGN NUMBER ] [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 245
    command                        shift and go to state 2

state 231

    (61) command -> ifelse : VAR SIGN : VAR [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 246
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 232

    (59) command -> ifelse : VAR SIGN NUMBER [ program ] . [ program ]

    [               shift and go to state 247


state 233

    (43) command -> setpencolor [ : VAR : VAR : VAR ] .

    forward         reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    fd              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    right           reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    rt              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    back            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    bk              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    left            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    lt              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    setpos          reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    setxy           reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    setx            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    sety            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    home            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    pendown         reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    pd              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    penup           reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    pu              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    setpencolor     reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    make            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    repeat          reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    while           reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    if              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    ifelse          reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    TO              reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    STR             reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    $end            reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    ]               reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)
    END             reduce using rule 43 (command -> setpencolor [ : VAR : VAR : VAR ] .)


state 234

    (49) command -> while [ : VAR SIGN NUMBER ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 248
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 235

    (54) command -> if [ NUMBER SIGN NUMBER ] [ program ] .

    forward         reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    fd              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    right           reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    rt              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    back            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    bk              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    left            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    lt              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    setpos          reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    setxy           reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    setx            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    sety            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    home            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    pendown         reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    pd              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    penup           reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    pu              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    setpencolor     reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    make            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    repeat          reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    while           reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    if              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    ifelse          reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    TO              reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    STR             reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    $end            reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    ]               reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)
    END             reduce using rule 54 (command -> if [ NUMBER SIGN NUMBER ] [ program ] .)


state 236

    (56) command -> if [ NUMBER SIGN : VAR ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 249
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 237

    (57) command -> if [ : VAR SIGN : VAR ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 250
    command                        shift and go to state 2

state 238

    (55) command -> if [ : VAR SIGN NUMBER ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 251
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 239

    (53) command -> if : VAR SIGN : VAR [ program ] .

    forward         reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    fd              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    right           reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    rt              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    back            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    bk              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    left            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    lt              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    setpos          reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    setxy           reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    setx            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    sety            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    home            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    pendown         reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    pd              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    penup           reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    pu              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    setpencolor     reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    make            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    repeat          reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    while           reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    if              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    ifelse          reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    TO              reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    STR             reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    $end            reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    ]               reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)
    END             reduce using rule 53 (command -> if : VAR SIGN : VAR [ program ] .)


state 240

    (58) command -> ifelse NUMBER SIGN NUMBER [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 252
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 241

    (60) command -> ifelse NUMBER SIGN : VAR [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 253
    command                        shift and go to state 2

state 242

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] . [ program ]

    [               shift and go to state 254


state 243

    (64) command -> ifelse [ NUMBER SIGN : VAR ] [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 255
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 244

    (65) command -> ifelse [ : VAR SIGN : VAR ] [ . program ] [ program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 256
    command                        shift and go to state 2

state 245

    (63) command -> ifelse [ : VAR SIGN NUMBER ] [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 257
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 246

    (61) command -> ifelse : VAR SIGN : VAR [ program ] . [ program ]

    [               shift and go to state 258


state 247

    (59) command -> ifelse : VAR SIGN NUMBER [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 259
    command                        shift and go to state 2

state 248

    (49) command -> while [ : VAR SIGN NUMBER ] [ program ] .

    forward         reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    fd              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    right           reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    rt              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    back            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    bk              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    left            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    lt              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    setpos          reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    setxy           reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    setx            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    sety            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    home            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    pendown         reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    pd              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    penup           reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    pu              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    setpencolor     reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    make            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    repeat          reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    while           reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    if              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    ifelse          reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    TO              reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    STR             reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    $end            reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    ]               reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)
    END             reduce using rule 49 (command -> while [ : VAR SIGN NUMBER ] [ program ] .)


state 249

    (56) command -> if [ NUMBER SIGN : VAR ] [ program ] .

    forward         reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    fd              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    right           reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    rt              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    back            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    bk              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    left            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    lt              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    setpos          reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    setxy           reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    setx            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    sety            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    home            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    pendown         reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    pd              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    penup           reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    pu              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    setpencolor     reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    make            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    repeat          reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    while           reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    if              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    ifelse          reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    TO              reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    STR             reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    $end            reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    ]               reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)
    END             reduce using rule 56 (command -> if [ NUMBER SIGN : VAR ] [ program ] .)


state 250

    (57) command -> if [ : VAR SIGN : VAR ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 260
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 251

    (55) command -> if [ : VAR SIGN NUMBER ] [ program ] .

    forward         reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    fd              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    right           reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    rt              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    back            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    bk              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    left            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    lt              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    setpos          reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    setxy           reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    setx            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    sety            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    home            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    pendown         reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    pd              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    penup           reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    pu              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    setpencolor     reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    make            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    repeat          reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    while           reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    if              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    ifelse          reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    TO              reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    STR             reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    $end            reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    ]               reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)
    END             reduce using rule 55 (command -> if [ : VAR SIGN NUMBER ] [ program ] .)


state 252

    (58) command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .

    forward         reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    fd              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    right           reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    rt              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    back            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    bk              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    left            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    lt              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    setpos          reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    setxy           reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    setx            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    sety            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    home            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    pendown         reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    pd              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    penup           reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    pu              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    setpencolor     reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    make            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    repeat          reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    while           reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    if              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    ifelse          reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    TO              reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    STR             reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    $end            reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    ]               reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)
    END             reduce using rule 58 (command -> ifelse NUMBER SIGN NUMBER [ program ] [ program ] .)


state 253

    (60) command -> ifelse NUMBER SIGN : VAR [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 261
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 254

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 262
    command                        shift and go to state 2

state 255

    (64) command -> ifelse [ NUMBER SIGN : VAR ] [ program ] . [ program ]

    [               shift and go to state 263


state 256

    (65) command -> ifelse [ : VAR SIGN : VAR ] [ program . ] [ program ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 264
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 257

    (63) command -> ifelse [ : VAR SIGN NUMBER ] [ program ] . [ program ]

    [               shift and go to state 265


state 258

    (61) command -> ifelse : VAR SIGN : VAR [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 266
    command                        shift and go to state 2

state 259

    (59) command -> ifelse : VAR SIGN NUMBER [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 267
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 260

    (57) command -> if [ : VAR SIGN : VAR ] [ program ] .

    forward         reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    fd              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    right           reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    rt              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    back            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    bk              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    left            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    lt              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    setpos          reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    setxy           reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    setx            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    sety            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    home            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    pendown         reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    pd              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    penup           reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    pu              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    setpencolor     reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    make            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    repeat          reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    while           reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    if              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    ifelse          reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    TO              reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    STR             reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    $end            reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    ]               reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)
    END             reduce using rule 57 (command -> if [ : VAR SIGN : VAR ] [ program ] .)


state 261

    (60) command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .

    forward         reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    fd              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    right           reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    rt              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    back            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    bk              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    left            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    lt              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    setpos          reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    setxy           reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    setx            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    sety            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    home            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    pendown         reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    pd              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    penup           reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    pu              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    setpencolor     reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    make            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    repeat          reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    while           reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    if              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    ifelse          reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    TO              reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    STR             reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    $end            reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    ]               reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)
    END             reduce using rule 60 (command -> ifelse NUMBER SIGN : VAR [ program ] [ program ] .)


state 262

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 268
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 263

    (64) command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 269
    command                        shift and go to state 2

state 264

    (65) command -> ifelse [ : VAR SIGN : VAR ] [ program ] . [ program ]

    [               shift and go to state 270


state 265

    (63) command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 271
    command                        shift and go to state 2

state 266

    (61) command -> ifelse : VAR SIGN : VAR [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 272
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 267

    (59) command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .

    forward         reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    fd              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    right           reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    rt              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    back            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    bk              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    left            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    lt              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    setpos          reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    setxy           reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    setx            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    sety            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    home            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    pendown         reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    pd              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    penup           reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    pu              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    setpencolor     reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    make            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    repeat          reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    while           reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    if              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    ifelse          reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    TO              reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    STR             reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    $end            reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    ]               reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)
    END             reduce using rule 59 (command -> ifelse : VAR SIGN NUMBER [ program ] [ program ] .)


state 268

    (62) command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .

    forward         reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    fd              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    right           reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    rt              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    back            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    bk              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    left            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    lt              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    setpos          reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    setxy           reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    setx            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    sety            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    home            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    pendown         reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    pd              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    penup           reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    pu              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    setpencolor     reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    make            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    repeat          reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    while           reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    if              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    ifelse          reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    TO              reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    STR             reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    $end            reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    ]               reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)
    END             reduce using rule 62 (command -> ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ] .)


state 269

    (64) command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 273
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 270

    (65) command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ . program ]
    (1) program -> . command
    (2) program -> . program command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    program                        shift and go to state 274
    command                        shift and go to state 2

state 271

    (63) command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 275
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 272

    (61) command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .

    forward         reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    fd              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    right           reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    rt              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    back            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    bk              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    left            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    lt              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    setpos          reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    setxy           reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    setx            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    sety            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    home            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    pendown         reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    pd              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    penup           reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    pu              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    setpencolor     reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    make            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    repeat          reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    while           reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    if              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    ifelse          reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    TO              reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    STR             reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    $end            reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    ]               reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)
    END             reduce using rule 61 (command -> ifelse : VAR SIGN : VAR [ program ] [ program ] .)


state 273

    (64) command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .

    forward         reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    fd              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    right           reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    rt              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    back            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    bk              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    left            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    lt              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    setpos          reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    setxy           reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    setx            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    sety            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    home            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    pendown         reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    pd              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    penup           reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    pu              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    setpencolor     reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    make            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    repeat          reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    while           reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    if              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    ifelse          reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    TO              reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    STR             reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    $end            reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    ]               reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)
    END             reduce using rule 64 (command -> ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ] .)


state 274

    (65) command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program . ]
    (2) program -> program . command
    (3) command -> . forward NUMBER
    (4) command -> . fd NUMBER
    (5) command -> . forward : VAR
    (6) command -> . fd : VAR
    (7) command -> . right NUMBER
    (8) command -> . rt NUMBER
    (9) command -> . right : VAR
    (10) command -> . rt : VAR
    (11) command -> . back NUMBER
    (12) command -> . bk NUMBER
    (13) command -> . back : VAR
    (14) command -> . bk : VAR
    (15) command -> . left NUMBER
    (16) command -> . lt NUMBER
    (17) command -> . left : VAR
    (18) command -> . lt : VAR
    (19) command -> . setpos [ NUMBER NUMBER ]
    (20) command -> . setxy NUMBER NUMBER
    (21) command -> . setpos [ : VAR NUMBER ]
    (22) command -> . setpos [ NUMBER : VAR ]
    (23) command -> . setpos [ : VAR : VAR ]
    (24) command -> . setxy : VAR NUMBER
    (25) command -> . setxy NUMBER : VAR
    (26) command -> . setxy : VAR : VAR
    (27) command -> . setx NUMBER
    (28) command -> . setx : VAR
    (29) command -> . sety NUMBER
    (30) command -> . sety : VAR
    (31) command -> . home
    (32) command -> . pendown
    (33) command -> . pd
    (34) command -> . penup
    (35) command -> . pu
    (36) command -> . setpencolor [ NUMBER NUMBER NUMBER ]
    (37) command -> . setpencolor [ NUMBER NUMBER : VAR ]
    (38) command -> . setpencolor [ NUMBER : VAR NUMBER ]
    (39) command -> . setpencolor [ NUMBER : VAR : VAR ]
    (40) command -> . setpencolor [ : VAR NUMBER NUMBER ]
    (41) command -> . setpencolor [ : VAR NUMBER : VAR ]
    (42) command -> . setpencolor [ : VAR : VAR NUMBER ]
    (43) command -> . setpencolor [ : VAR : VAR : VAR ]
    (44) command -> . make " VAR NUMBER
    (45) command -> . make " VAR : VAR OPERATOR NUMBER
    (46) command -> . make " VAR NUMBER OPERATOR : VAR
    (47) command -> . repeat NUMBER [ program ]
    (48) command -> . repeat : VAR [ program ]
    (49) command -> . while [ : VAR SIGN NUMBER ] [ program ]
    (50) command -> . if NUMBER SIGN NUMBER [ program ]
    (51) command -> . if : VAR SIGN NUMBER [ program ]
    (52) command -> . if NUMBER SIGN : VAR [ program ]
    (53) command -> . if : VAR SIGN : VAR [ program ]
    (54) command -> . if [ NUMBER SIGN NUMBER ] [ program ]
    (55) command -> . if [ : VAR SIGN NUMBER ] [ program ]
    (56) command -> . if [ NUMBER SIGN : VAR ] [ program ]
    (57) command -> . if [ : VAR SIGN : VAR ] [ program ]
    (58) command -> . ifelse NUMBER SIGN NUMBER [ program ] [ program ]
    (59) command -> . ifelse : VAR SIGN NUMBER [ program ] [ program ]
    (60) command -> . ifelse NUMBER SIGN : VAR [ program ] [ program ]
    (61) command -> . ifelse : VAR SIGN : VAR [ program ] [ program ]
    (62) command -> . ifelse [ NUMBER SIGN NUMBER ] [ program ] [ program ]
    (63) command -> . ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ]
    (64) command -> . ifelse [ NUMBER SIGN : VAR ] [ program ] [ program ]
    (65) command -> . ifelse [ : VAR SIGN : VAR ] [ program ] [ program ]
    (69) command -> . TO STR varlist program END
    (73) command -> . STR valuelist

    ]               shift and go to state 276
    forward         shift and go to state 3
    fd              shift and go to state 4
    right           shift and go to state 5
    rt              shift and go to state 6
    back            shift and go to state 7
    bk              shift and go to state 8
    left            shift and go to state 9
    lt              shift and go to state 10
    setpos          shift and go to state 11
    setxy           shift and go to state 12
    setx            shift and go to state 13
    sety            shift and go to state 14
    home            shift and go to state 15
    pendown         shift and go to state 16
    pd              shift and go to state 17
    penup           shift and go to state 18
    pu              shift and go to state 19
    setpencolor     shift and go to state 20
    make            shift and go to state 21
    repeat          shift and go to state 22
    while           shift and go to state 23
    if              shift and go to state 24
    ifelse          shift and go to state 25
    TO              shift and go to state 26
    STR             shift and go to state 27

    command                        shift and go to state 28

state 275

    (63) command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .

    forward         reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    fd              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    right           reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    rt              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    back            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    bk              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    left            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    lt              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    setpos          reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    setxy           reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    setx            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    sety            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    home            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    pendown         reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    pd              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    penup           reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    pu              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    setpencolor     reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    make            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    repeat          reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    while           reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    if              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    ifelse          reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    TO              reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    STR             reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    $end            reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    ]               reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)
    END             reduce using rule 63 (command -> ifelse [ : VAR SIGN NUMBER ] [ program ] [ program ] .)


state 276

    (65) command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .

    forward         reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    fd              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    right           reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    rt              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    back            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    bk              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    left            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    lt              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    setpos          reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    setxy           reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    setx            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    sety            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    home            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    pendown         reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    pd              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    penup           reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    pu              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    setpencolor     reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    make            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    repeat          reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    while           reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    if              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    ifelse          reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    TO              reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    STR             reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    $end            reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    ]               reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)
    END             reduce using rule 65 (command -> ifelse [ : VAR SIGN : VAR ] [ program ] [ program ] .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NUMBER in state 27 resolved as shift
WARNING: shift/reduce conflict for : in state 63 resolved as shift
